## 5月2号

1. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || in.length == 0 || pre.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                root.right = buildTree(Arrays.copyOfRange(pre,i+1,pre.length), Arrays.copyOfRange(in, i+1, in.length));
            }
        }
        return root;
    }
}
```

* 解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来

2. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        // if() return false;
        ListNode mid = findMid(head);
        ListNode reverse = reverseList(mid);
        while(head != mid) {
            if(head.val != reverse.val) return false;
            head = head.next;
            reverse = reverse.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head) {
        ListNode newHead = new ListNode(-1);
        ListNode t = null;
        while(head != null) {
            t = head.next;
            head.next = newHead.next;
            newHead.next = head;
            head = t;
        }
        return newHead.next;
    }
    ListNode findMid(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

## 5月3号

1. [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```Java

class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || pre.length == 0 || in.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                root.right = buildTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return root;
    }
}
```

2. [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```Java
class Solution {
    boolean[][] v;
    char[] c;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board[0].length == 0) return false;
        v = new boolean[board.length][board[0].length];
        c = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, i, j, 0)) return true;
            }
        }
        return false;
    }

    boolean dfs(char[][] board, int row, int col, int len) {
        if(v[row][col] || board[row][col] != c[len]) return false;
        if(len == c.length - 1) return true; 
        v[row][col] = true;
        if(row > 0 && dfs(board, row - 1, col, len + 1)) return true;
        if(row < board.length - 1 && dfs(board, row + 1, col, len + 1)) return true;
        if(col > 0 && dfs(board, row, col - 1, len + 1)) return true;
        if(col < board[0].length - 1 && dfs(board, row, col + 1, len + 1)) return true;
        v[row][col] = false;
        return false;
    }
}	
```

3. [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```Java
class Solution {
    boolean[][] v;
    int threshold;
    public int movingCount(int m, int n, int k) {
        v = new boolean[m][n];
        threshold = k;
        return dfs(m,n,0,0);
    }
    int dfs(int rows, int cols, int row, int col) {
        int count = 0;
        if(row < rows && col <cols && sum(row) + sum(col) <= threshold && !v[row][col]){
            v[row][col] = true;
            count = 1 + dfs(rows, cols, row + 1, col) + dfs(rows, cols, row, col + 1);
        }
        return count;
    }
    int sum(int n) {
        int sum = 0;
        while(n > 0){
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
}
```

* 还需要再复习一下

## 5月4号

1. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```Java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() < 1) return "";
        int left = 0, right = 0;
        for(int i = 0; i < s.length() - 1; i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if(len > (right - left + 1)) {
                left = i - (len - 1) / 2;// 注意此处是 len - 1
                right = i + len / 2;
            }
        }
        return s.substring(left, right + 1);
    }

    private int expand(String s, int i, int j) {
        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {
            i--; j++;
        }
        return j - i - 1;
    }
}
```

2. [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```java
class Solution {
    public int myAtoi(String str) {
        if(str.length() == 0) return 0;
        int index = 0, res = 0;
        while(index < str.length() && str.charAt(index) == ' ') index++;
        if(index == str.length()) return 0;
        boolean positive = true;
        char fristChar = str.charAt(index);
        if(!isNum(fristChar)) {
            if(fristChar != '+' && fristChar != '-') return 0;
            positive = (fristChar != '-');
            index++;
        }
        int limit = positive ? -Integer.MAX_VALUE : Integer.MIN_VALUE;
        while(index < str.length() && isNum(str.charAt(index))) {
            int t = str.charAt(index++) - '0';
            // 如果 res * 10 - t 越界, 那么 res * 10 - t < limit
            if(res < (limit + t) / 10) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 - t;
        }

        return positive ? -res : res;
    }
    private boolean isNum(char c) {
        int t = c - '0';
        if(t >= 0 && t <= 9) return true;
        return false;
    }
}
```

## 5月5号

1. [组合总和](https://leetcode-cn.com/problems/combination-sum/)

* 典型的回溯法解题，需要考虑去重
* 回溯法的应用：当需要对所有的结果进行暴力搜索，也就是对决策树进行遍历，适当的时候进行剪枝

```Pytho
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates.length == 0) return res;
        List<Integer> list = new ArrayList<>();
        backtrack(list, candidates, target, 0);
        return res;
    }
    // 剪枝方法：使用了一个 index 记录当前的访问位置，每次回溯的时候保证不会往后走，只会往前走。
    void backtrack(List<Integer> list, int[] candidates, int target, int index) {
        if(target == 0) {
            res.add(new ArrayList(list));
            return;
        }
        if(target > 0) {
            for(int i = index; i < candidates.length; i++) {
                list.add(candidates[i]);
                
                // 因为组合中可以由重复的数字出现：223 7， 所以每次回溯的时候继续从当前位置走
                backtrack(list, candidates, target - candidates[i], i);
                list.remove(list.size() - 1);
            }
        }
    }

// 剪枝方法：维护一个非递减的列表，所以既满足了组合中可以出现重复数字，并且不会出现每次组合重复的情况
// 例如 223 232 322 都可以是 7 的组合，但是限制了非递减 所以结果只有 322
    
    // void backtrack(List<Integer> list, int[] candidates, int target ) {
    //     if(target == 0) {
    //         res.add(new ArrayList(list));
    //         return;
    //     }
    //     if(target > 0) {
    //         for(int i = 0; i < candidates.length; i++) {
    //             if(!list.isEmpty() && candidates[i] > list.get(list.size() - 1)) continue;
    //             list.add(candidates[i]);
    //             dfs(list, candidates, target - candidates[i]);
    //             list.remove(list.size() - 1);
    //         }
    //     }
    // }
}
```

2. [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```Java
// // 例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下： 
// // 自右至左找出排列中第一个比右边数字小的数字4     839647521
// // 在该数字后自右向左找到第一个比4大的数字5       839647521
// // 将5与4交换                                839657421
// // 将7421倒转                                839651247
// // 所以839647521的下一个排列是                 839651247。

class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length < 2) return;
        int j = nums.length - 2;
        while(j >= 0 && nums[j] >= nums[j + 1]) j--;
        if(j == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int i = nums.length - 1;
        while(i > j && nums[i] <= nums[j]) i--;
        swap(nums, i, j);
        reverse(nums, j + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int L, int R) {
        while(L < R) {
            swap(nums, L++, R--);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

3. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root, pre = null;
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            // 中序遍历是一个单调递增的序列
            if(pre != null && pre.val >= cur.val) return false;
            pre = cur;
            cur = cur.right;
        }
        return true;
    }
    
    // 每次记录 up down 即父节点和子节点
    // public boolean isValidBST(TreeNode root) {
    //     if(root == null) return true;
    //     return help(root, Long.MAX_VALUE,Long.MIN_VALUE);
    // }

    // private boolean help(TreeNode root, long up, long down) {
    //     if(root != null) {
    //         if(root.val >= up) return false;
    //         if(root.val <= down) return false;
    //         return help(root.left, root.val, down) && help(root.right, up, root.val);
    //     }
    //     return true;
    // }
}
```

4. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        // 初始化的时候不能为null 否则之后的判断不合理
        // 但是让pre = root 也不合理，因为此时上次访问的节点不是root !!!待解决
        TreeNode pre = root; 
        s.push(root);
        while(s.size() > 0) {
            TreeNode t = s.peek();
            // 当pre为空的时候，有一个节点其右节点为空，那么此时 pre == t.right
            if(t.left != null && pre != t.left && pre != t.right) { 
                s.push(t.left);
            } else if(t.right != null && pre != t.right) { 
                s.push(t.right);
            } else {
                TreeNode cur = s.pop();
                pre = cur;
                res.add(cur.val);
            }
        }
        return res;
    }
}
```

5. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root; 
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                res.add(cur.val);
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            cur = cur.right;
        }
        return res;
    }

    // public List<Integer> preorderTraversal(TreeNode root) {
    //     List<Integer> res = new ArrayList<>();
    //     if(root == null) return res;
    //     Stack<TreeNode> s = new Stack<>();
    //     s.push(root);
    //     while(s.size() > 0) {
    //         TreeNode cur = s.pop();
    //         res.add(cur.val);
    //         if(cur.right != null) s.push(cur.right);
    //         if(cur.left != null) s.push(cur.left);
    //     }
    //     return res;
    // }
}
```

