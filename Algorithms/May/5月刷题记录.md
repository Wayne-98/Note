---
title: 5月刷题记录
date: {date}
tags: Algorithms
categories: Algorithms
---

## 5月2号

1. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || in.length == 0 || pre.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                root.right = buildTree(Arrays.copyOfRange(pre,i+1,pre.length), Arrays.copyOfRange(in, i+1, in.length));
            }
        }
        return root;
    }
}
```

* 解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来

2. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        // if() return false;
        ListNode mid = findMid(head);
        ListNode reverse = reverseList(mid);
        while(head != mid) {
            if(head.val != reverse.val) return false;
            head = head.next;
            reverse = reverse.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head) {
        ListNode newHead = new ListNode(-1);
        ListNode t = null;
        while(head != null) {
            t = head.next;
            head.next = newHead.next;
            newHead.next = head;
            head = t;
        }
        return newHead.next;
    }
    ListNode findMid(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

## 5月3号

1. [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```Java

class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || pre.length == 0 || in.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                root.right = buildTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return root;
    }
}
```

2. [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```Java
class Solution {
    boolean[][] v;
    char[] c;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board[0].length == 0) return false;
        v = new boolean[board.length][board[0].length];
        c = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, i, j, 0)) return true;
            }
        }
        return false;
    }

    boolean dfs(char[][] board, int row, int col, int len) {
        if(v[row][col] || board[row][col] != c[len]) return false;
        if(len == c.length - 1) return true; 
        v[row][col] = true;
        if(row > 0 && dfs(board, row - 1, col, len + 1)) return true;
        if(row < board.length - 1 && dfs(board, row + 1, col, len + 1)) return true;
        if(col > 0 && dfs(board, row, col - 1, len + 1)) return true;
        if(col < board[0].length - 1 && dfs(board, row, col + 1, len + 1)) return true;
        v[row][col] = false;
        return false;
    }
}	
```

3. [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```Java
class Solution {
    boolean[][] v;
    int threshold;
    public int movingCount(int m, int n, int k) {
        v = new boolean[m][n];
        threshold = k;
        return dfs(m,n,0,0);
    }
    int dfs(int rows, int cols, int row, int col) {
        int count = 0;
        if(row < rows && col <cols && sum(row) + sum(col) <= threshold && !v[row][col]){
            v[row][col] = true;
            count = 1 + dfs(rows, cols, row + 1, col) + dfs(rows, cols, row, col + 1);
        }
        return count;
    }
    int sum(int n) {
        int sum = 0;
        while(n > 0){
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
}
```

* 还需要再复习一下

## 5月4号

1. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```Java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() < 1) return "";
        int left = 0, right = 0;
        for(int i = 0; i < s.length() - 1; i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if(len > (right - left + 1)) {
                left = i - (len - 1) / 2;// 注意此处是 len - 1
                right = i + len / 2;
            }
        }
        return s.substring(left, right + 1);
    }

    private int expand(String s, int i, int j) {
        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {
            i--; j++;
        }
        return j - i - 1;
    }
}
```

2. [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```java
class Solution {
    public int myAtoi(String str) {
        if(str.length() == 0) return 0;
        int index = 0, res = 0;
        while(index < str.length() && str.charAt(index) == ' ') index++;
        if(index == str.length()) return 0;
        boolean positive = true;
        char fristChar = str.charAt(index);
        if(!isNum(fristChar)) {
            if(fristChar != '+' && fristChar != '-') return 0;
            positive = (fristChar != '-');
            index++;
        }
        int limit = positive ? -Integer.MAX_VALUE : Integer.MIN_VALUE;
        while(index < str.length() && isNum(str.charAt(index))) {
            int t = str.charAt(index++) - '0';
            // 如果 res * 10 - t 越界, 那么 res * 10 - t < limit
            if(res < (limit + t) / 10) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 - t;
        }

        return positive ? -res : res;
    }
    private boolean isNum(char c) {
        int t = c - '0';
        if(t >= 0 && t <= 9) return true;
        return false;
    }
}
```

## 5月5号

1. [组合总和](https://leetcode-cn.com/problems/combination-sum/)

* 典型的回溯法解题，需要考虑去重
* 回溯法的应用：当需要对所有的结果进行暴力搜索，也就是对决策树进行遍历，适当的时候进行剪枝

```Pytho
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates.length == 0) return res;
        List<Integer> list = new ArrayList<>();
        backtrack(list, candidates, target, 0);
        return res;
    }
    // 剪枝方法：使用了一个 index 记录当前的访问位置，每次回溯的时候保证不会往后走，只会往前走。
    void backtrack(List<Integer> list, int[] candidates, int target, int index) {
        if(target == 0) {
            res.add(new ArrayList(list));
            return;
        }
        if(target > 0) {
            for(int i = index; i < candidates.length; i++) {
                list.add(candidates[i]);
                
                // 因为组合中可以由重复的数字出现：223 7， 所以每次回溯的时候继续从当前位置走
                backtrack(list, candidates, target - candidates[i], i);
                list.remove(list.size() - 1);
            }
        }
    }

// 剪枝方法：维护一个非递减的列表，所以既满足了组合中可以出现重复数字，并且不会出现每次组合重复的情况
// 例如 223 232 322 都可以是 7 的组合，但是限制了非递减 所以结果只有 322
    
    // void backtrack(List<Integer> list, int[] candidates, int target ) {
    //     if(target == 0) {
    //         res.add(new ArrayList(list));
    //         return;
    //     }
    //     if(target > 0) {
    //         for(int i = 0; i < candidates.length; i++) {
    //             if(!list.isEmpty() && candidates[i] > list.get(list.size() - 1)) continue;
    //             list.add(candidates[i]);
    //             dfs(list, candidates, target - candidates[i]);
    //             list.remove(list.size() - 1);
    //         }
    //     }
    // }
}
```

2. [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```Java
// // 例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下： 
// // 自右至左找出排列中第一个比右边数字小的数字4     839647521
// // 在该数字后自右向左找到第一个比4大的数字5       839647521
// // 将5与4交换                                839657421
// // 将7421倒转                                839651247
// // 所以839647521的下一个排列是                 839651247。

class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length < 2) return;
        int j = nums.length - 2;
        while(j >= 0 && nums[j] >= nums[j + 1]) j--;
        if(j == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int i = nums.length - 1;
        while(i > j && nums[i] <= nums[j]) i--;
        swap(nums, i, j);
        reverse(nums, j + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int L, int R) {
        while(L < R) {
            swap(nums, L++, R--);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

3. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root, pre = null;
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            // 中序遍历是一个单调递增的序列
            if(pre != null && pre.val >= cur.val) return false;
            pre = cur;
            cur = cur.right;
        }
        return true;
    }
    
    // 每次记录 up down 即父节点和子节点
    // public boolean isValidBST(TreeNode root) {
    //     if(root == null) return true;
    //     return help(root, Long.MAX_VALUE,Long.MIN_VALUE);
    // }

    // private boolean help(TreeNode root, long up, long down) {
    //     if(root != null) {
    //         if(root.val >= up) return false;
    //         if(root.val <= down) return false;
    //         return help(root.left, root.val, down) && help(root.right, up, root.val);
    //     }
    //     return true;
    // }
}
```

4. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        // 初始化的时候不能为null 否则之后的判断不合理
        // 但是让pre = root 也不合理，因为此时上次访问的节点不是root !!!待解决
        TreeNode pre = root; 
        s.push(root);
        while(s.size() > 0) {
            TreeNode t = s.peek();
            // 当pre为空的时候，有一个节点其右节点为空，那么此时 pre == t.right
            if(t.left != null && pre != t.left && pre != t.right) { 
                s.push(t.left);
            } else if(t.right != null && pre != t.right) { 
                s.push(t.right);
            } else {
                TreeNode cur = s.pop();
                pre = cur;
                res.add(cur.val);
            }
        }
        return res;
    }
}
```

5. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root; 
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                res.add(cur.val);
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            cur = cur.right;
        }
        return res;
    }

    // public List<Integer> preorderTraversal(TreeNode root) {
    //     List<Integer> res = new ArrayList<>();
    //     if(root == null) return res;
    //     Stack<TreeNode> s = new Stack<>();
    //     s.push(root);
    //     while(s.size() > 0) {
    //         TreeNode cur = s.pop();
    //         res.add(cur.val);
    //         if(cur.right != null) s.push(cur.right);
    //         if(cur.left != null) s.push(cur.left);
    //     }
    //     return res;
    // }
}
```

## 5月6号

1. [N皇后](https://leetcode-cn.com/problems/n-queens/)

```Java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        if(n == 0) return res;
        char[][] board = new char[n][n];
        for(char[] ch : board) Arrays.fill(ch, '.');
        backtrack(board, 0);
        return res;
    }

    void backtrack(char[][] board, int row) {
        if(row == board.length) {
            res.add(charsToString(board));
            return;
        }
        for(int col = 0; col < board[0].length; col++) {
            if(isValid(board, row, col)) {
                board[row][col] = 'Q';
                backtrack(board, row + 1);
                board[row][col] = '.';
            }
        }
    }

    private boolean isValid(char[][] board, int row, int col) {
        for(char[] c : board)
            if(c[col] == 'Q')
                return false;
        for(int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--)
            if(board[i][j] == 'Q')
                return false;
        for(int i = row - 1, j = col + 1; i >= 0 && j < board[i].length; i--, j++)
            if(board[i][j] == 'Q')
                return false;
        return true;
    }

    private List<String> charsToString(char[][] c){
        List<String> l = new ArrayList<>();
        for(char[] ch : c) {
            l.add(String.valueOf(ch));
        }
        return l;
    }
}
```

2. [全排列](https://leetcode-cn.com/problems/permutations/)

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] v;
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length < 1) return res;
        v = new boolean[nums.length];
        backtrack(nums);
        return res;
    }
    void backtrack(int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < nums.length; i++) {
            if(!v[i]) {
                v[i] = true;
                path.add(nums[i]);
                backtrack(nums);
                path.remove(path.size() - 1);
                v[i] = false;
            }
        }
    }
}
```

3. [LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

```Java
class LRUCache {
    Map<Integer, Node> m;
    DoubleList cache;
    int capacity;
    public LRUCache(int capacity) {
        m = new HashMap<>();
        cache = new DoubleList();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if(m.containsKey(key)) {
            int val = m.get(key).value;
            put(key,val);
            return val;
        } else {
            return -1;
        }
    }
    
    public void put(int key, int value) {
        Node node = new Node(key, value);
        if(m.containsKey(key)) {
            cache.remove(m.get(key));
            cache.addFirst(node);
            m.put(key, node);
        } else {
            if(cache.size == capacity) {
                Node last = cache.removeLast();
                m.remove(last.key);
            }
            cache.addFirst(node);
            m.put(key, node);
        }

    }

    private class DoubleList{
        Node head;
        Node tail;
        int size;
        public DoubleList() {
            this.head = new Node(-1, -1);
            this.tail = new Node(-1, -1);
            head.next = tail;
            tail.pre = head;
            this.size = 0;
        }

        public void addFirst(Node node) {
            size++;
            node.pre = head;
            node.next = head.next;
            head.next.pre = node;
            head.next = node;
        }

        public void remove(Node node) {
            size--;
            node.next.pre = node.pre;
            node.pre.next = node.next;
        }

        public Node removeLast() {
            if(tail.pre == head) return null;
            Node last = tail.pre;
            remove(last);
            return last;
        }
    }

    private class Node{
        int key;
        int value;
        Node pre;
        Node next;
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

4. [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```Java
class Solution {
    public void rotate(int[][] matrix) {
        int temp = -1;
        // 第一个 for 用来控制每次的方块大小，因为是 n * n 的，所以用两个变量就okk
        for(int start = 0, end = matrix[0].length - 1; start < end; start++, end--) {
            
            // 第二个 for 用来交换本次方块的值
            for(int s = start, e = end; s < end; s++, e--) {
                temp = matrix[start][s];
                matrix[start][s] = matrix[e][start];
                matrix[e][start] = matrix[end][e];
                matrix[end][e] = matrix[s][end];
                matrix[s][end] = temp;
            }
        }
    }
}

```

5. [不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```Java
class Solution {
    public int add(int a, int b) {
        while(b != 0) {
            int t = a ^ b;
            b = ((a & b) << 1);
            a = t;
        }
        return a;
    }
}

// 异或：相同则为0 不同则为1，相当于 两个数的不进位和
// & << 1：相当于两个数和的进位
```

## 5月7号

1. [从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder.length == 0 || postorder.length == 0) return null;
        TreeNode root = new TreeNode(postorder[postorder.length - 1]);
        for(int i = 0; i < inorder.length; i++) {
            if(inorder[i] == root.val) {
                root.left = buildTree(Arrays.copyOfRange(inorder, 0, i), Arrays.copyOfRange(postorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(inorder, i + 1, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length - 1));
            }
        }
        return root;
    //     return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    // private TreeNode build(int[] in, int inL, int inR, int[] post, int postL, int postR) {
    //     if(inL > inR || postL > postR) return null;
    //     TreeNode root = new TreeNode(post[postR]);
    //     int i = 0;
    //     while(in[inL + i] != root.val) i++;
    //     root.left = build(in, inL, inL + i - 1, post, postL, postL + i - 1);
    //     root.right = build(in, inL + i + 1, inR, post, postL + i, postR - 1);
    //     return root;
    // }

}
```

2. [将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums, 0, nums.length);
    }
    TreeNode toBST(int[] nums, int left, int right){
        if(left >= right) return null;
        int mid = left + ((right - left) >> 1);
        TreeNode root = new TreeNode(nums[mid]);
        root.left = toBST(nums, left, mid);
        root.right = toBST(nums, mid + 1, right);
        return root;
    }
}
```

## 5月8号

1. [相同的树](https://leetcode-cn.com/problems/same-tree/)

```Java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null || q == null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

2. [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return help(root) != -1;
    }

    int help(TreeNode root) {
        if(root == null) return 0;
        int left = help(root.left);
        if(left == -1) return -1;
        int right = help(root.right);
        if(right == -1) return -1;
        // 如果左右子树的高度差小于2，那么返回 当前节点的高度，否则剪枝输出 -1
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1: -1;
    }

}
// class Solution {
//     public boolean isBalanced(TreeNode root) {
//         // 如果遍历到叶子节点以下，则返回真
//         if(root == null) return true;   

//         // 对每个遍历的节点，查看其左右子树的高度差是否大于1
//         if(Math.abs(high(root.left) - high(root.right)) > 1) return false;

//         // 前序遍历每一个节点
//         return isBalanced(root.left) && isBalanced(root.right);
//     }

//     private int high(TreeNode root) {
//         if(root == null) return 0;
//         return Math.max(high(root.left), high(root.right)) + 1;
//     }
// }
```

3. [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        if(root.left == null && root.right != null) return minDepth(root.right) + 1;
        if(root.right == null && root.left != null) return minDepth(root.left) + 1;
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}
// 因为最小深度，并不像最大深度那样，每次都遍历到最底部，因为可能左子树为空，右子树不空，那么此时就会直接返回左子树的高度 0 + 1，而不是右子树的高度。这样不能全部遍历到整棵树，所以也无法求得全局最小深度
```

4. [路径总和](https://leetcode-cn.com/problems/path-sum/)

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && sum != root.val) return false;
        if(root.left == null && root.right == null && sum == root.val) return true;
        // if(root.left == null && root.right == null) return sum == root.val;
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

5. [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if(root == null) return res;
        backtrack(root, sum);
        return res;
    }

    void backtrack(TreeNode root, int sum) {
        if(root == null) return;
        if(root.left == null && root.right == null && sum == root.val) {
            path.add(root.val);
            res.add(new ArrayList<>(path));
            path.remove(path.size() - 1);
            return;
        }
        path.add(root.val);
        backtrack(root.left, sum - root.val);
        // path.remove(path.size() - 1);
        // path.add(root.val);
        backtrack(root.right, sum - root.val);
        path.remove(path.size() - 1);
    }
}
```

6. [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

   [填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```Java
class Solution {
    public Node connect(Node root) {
        if(root == null) return null;
        LinkedList<Node> q = new LinkedList<>();
        q.offer(root);
        while(q.size() > 0) {
            int size = q.size();
            for(int i = 0; i < size; i++) {
                Node t = q.poll();
                if(i == size - 1) { // 此处，不能用队列的size判断，因为下面还会添加Node
                    t.next = null;
                } else {
                    t.next = q.peekFirst();
                }
                if(t.left != null) q.offer(t.left);
                if(t.right != null) q.offer(t.right);
            }
        }
        return root;
    }
}
```

7. [求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```Java
class Solution {
    int sum = 0;
    int path = 0;
    public int sumNumbers(TreeNode root) {
        if(root == null) return sum;
        backtrack(root);
        return sum;
    }

    void backtrack(TreeNode root) {
        if(root == null) return;
        path = path * 10 + root.val;
        if(root.left == null && root.right == null) sum += path;
        backtrack(root.left);
        backtrack(root.right);
        path = (path - root.val) / 10;
    }
}
```

8. [二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

* 这一题要转换思路，题目看起来很麻烦，其实就是很简单的非递归中序遍历

```Java
class BSTIterator {
    Deque<TreeNode> stack;
    public BSTIterator(TreeNode root) {
        stack = new ArrayDeque<>();
        left(root);
    }
    
    private void left(TreeNode root) {
        while(root != null) {
            stack.push(root);
            root = root.left;
        }
    }
    /** @return the next smallest number */
    public int next() {
        TreeNode t = stack.pop();
        left(t.right);
        return t.val;
    }
    
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return stack.size() > 0;
    }
}
```

9. [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/

```Java
class Trie {

    private TrieNode root;
    /** Initialize your data structure here. */
    public Trie() {
        this.root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode temp = root;
        for(int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            TrieNode node = temp.getSubNode(c);
            if(node == null) {
                node = new TrieNode();
                temp.addSubNode(c, node);
            }
            temp = node;
            if(i == word.length() - 1)
                temp.setEnd(true);
            
        }
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode temp = root;
        for(int i = 0; i < word.length(); i++) {
           TrieNode node = temp.getSubNode(word.charAt(i));
           if(node == null) return false;
           temp = node;
           if(i == word.length() - 1)
                return temp.getEnd();
        }
        return true;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode temp = root;
        for(int i = 0; i < prefix.length(); i++) {
           TrieNode node = temp.getSubNode(prefix.charAt(i));
           if(node == null) return false;
           temp = node;
        }
        return true;
    }

private class TrieNode{

    private Map<Character,TrieNode> subNodes = new HashMap<>();
    private boolean end;

    public void addSubNode(Character key, TrieNode value) {
        subNodes.put(key, value);
    }
    public TrieNode getSubNode(Character key) {
        return subNodes.get(key);
    }
        
    public void setEnd(boolean end) {
        this.end = end;
    }

    public boolean getEnd(){
        return this.end;
    }
}

}
```

## 5月9号

1. [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```Java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        LinkedList<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(q.size() > 0) {
            int size = q.size(); 
            for(int i = 0; i < size; i++) {
                TreeNode t = q.poll();
                if(t.left != null) q.offer(t.left);
                if(t.right != null) q.offer(t.right);
                if(i == size - 1)
                    res.add(t.val);
            }
        }
        return res;
    }
}
```

2. [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        if(root.left == null && root.right == null) return root;
        TreeNode t = root.left;
        root.left = root.right;
        root.right = t;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

3. [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null) {
            if(root == p || root == q || (p.val < root.val && q.val > root.val) || (p.val > root.val && q.val < root.val)) return root;
            if(p.val > root.val && q.val > root.val) root = root.right;
            else root = root.left;
        }
        return root;
    }
}
```

4. [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```Java
class Solution {
    List<String> path = new ArrayList<>();
    List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null) return res;
        backtrack(root);
        return res;
    }

    void backtrack(TreeNode root) {
        if(root == null) return;
        if(root.left == null && root.right == null) {
            path.add(root.val + "");
            res.add(String.join("->",path));
            path.remove(path.size() - 1);
        }
        path.add(root.val + "");
        backtrack(root.left);
        backtrack(root.right);
        path.remove(path.size() - 1);
    }
}
```

5. [二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```Java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode cur = root;
        int i = 0;
        while(stack.size() > 0 || cur != null) {
            while(cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            if(++i == k)
                return cur.val;
            cur = cur.right;
        }
        return 0;
    }
}
```

6. [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

```Java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        sb.append(root.val + ",");
        while(queue.size() > 0) {
            TreeNode temp = queue.poll();
            if(temp.left != null) {
                queue.offer(temp.left);
                sb.append(temp.left.val + ",");
            } else {
                sb.append("null,");
            }
            if(temp.right != null) {
                queue.offer(temp.right);
                sb.append(temp.right.val + ",");
            } else {
                sb.append("null,");
            }
        }
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if("".equals(data)) return null;
        String[] strs = data.split(",");
        TreeNode root = generateTreeNode(strs[0]);
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int index = 1;
        while(queue.size() > 0) {
            TreeNode t = queue.poll();
            t.left = generateTreeNode(strs[index++]);
            if(t.left != null) queue.offer(t.left);
            t.right = generateTreeNode(strs[index++]);
            if(t.right != null) queue.offer(t.right);
        }
        return root;
    }

    private TreeNode generateTreeNode(String str) {
        if("null".equals(str))
            return null;
        return new TreeNode(Integer.parseInt(str));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

7. [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

* 动态规划的 转移方程

```Java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        int res = nums[0];
        for(int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

8. [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```Java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0; 
        if(nums.length == 1) return nums[0];
        return Math.max(get(Arrays.copyOfRange(nums, 0, nums.length - 1)), get(Arrays.copyOfRange(nums, 1, nums.length)));
    }

    public int get(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        int res = dp[1];
        for(int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
    
}
```

9. [打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```Java
class Solution {
    Map<TreeNode, Integer> memo = new HashMap<>();
    public int rob(TreeNode root) {
        if(root == null) return 0;
        if(memo.containsKey(root)) return memo.get(root);
        int doIt = root.val + 
        (root.left == null ? 0 : rob(root.left.left) + rob(root.left.right)) +  
        (root.right == null ? 0 : rob(root.right.left) + rob(root.right.right));
        int notDoIt = rob(root.left) + rob(root.right);
        int result = Math.max(doIt, notDoIt);
        memo.put(root, result);
        return result;
    }
}
```

10. [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        int min = prices[0];
        int res = 0;
        for(int i = 1; i < prices.length; i++) {
            res = Math.max(res, prices[i] - min);
            min = Math.min(min, prices[i]);
        }
        return res;
    }
}
```

11. [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```Java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        for(int i = 1; i < prices.length; i++) {
            res += prices[i] - prices[i - 1] <= 0 ? 0 : prices[i] - prices[i - 1];
        }
        return res;
    }
}
```

12. [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```Java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;

        int[] dp = new int[prices.length];
        int[] reverseDp = new int[prices.length];

        int min = prices[0];
        for(int i = 1; i < prices.length; i++) {
            min = Math.min(min, prices[i]);
            dp[i] = Math.max(dp[i - 1], prices[i] - min);
        }

        int max = prices[prices.length - 1];
        for(int i = prices.length - 2; i >= 0; i--) {
            max = Math.max(max, prices[i]);
            reverseDp[i] = Math.max(reverseDp[i + 1], max - prices[i]);
        }
        
        int res = dp[prices.length - 1];
        for(int i = 0; i < prices.length - 1; i++) {
            res = Math.max(res, dp[i] + reverseDp[i + 1]);
        }
        return res;
    }
}
```

## 5月10号

1. [左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```Java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        int count = 0;
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(queue.size() > 0) {
            int size = queue.size();
            for(int i = 0; i < size; i++) {
                TreeNode t = queue.poll();
                if(t.left != null) {
                    queue.offer(t.left);
                    if(t.left.left == null && t.left.right == null) count += t.left.val;
                }
                if(t.right != null) queue.offer(t.right);
            }
        }
        return count;
    }
}
```

2. [路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

```Java
class Solution {
    int count = 0;
    int sum;
    public int pathSum(TreeNode root, int sum) {
        if(root == null) return 0;
        this.sum = sum;
        preOrder(root);
        return count;
    }
    private void preOrder(TreeNode root) {
        if(root == null) return;
        backtrack(root);
        preOrder(root.left);
        preOrder(root.right);
    }

    private void backtrack(TreeNode root) {
        if(root == null) return;
        sum -= root.val;
        if(sum == 0) count++;
        backtrack(root.left);
        backtrack(root.right);
        sum += root.val;
    }
}
```

3. [序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

```Java
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        preOrder(root, sb);
        return sb.deleteCharAt(sb.length() - 1).toString();
    }
    private void preOrder(TreeNode root, StringBuilder sb) {
        if(root == null) return;
        sb.append(root.val + ",");
        preOrder(root.left, sb);
        preOrder(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if("".equals(data)) return null;
        String[] strs = data.split(",");
        return rebuild(strs, 0, strs.length - 1);
    }
    private TreeNode rebuild(String[] strs, int low, int high) {
        if(low > high) return null;
        TreeNode root = new TreeNode(Integer.parseInt(strs[low]));
        int i;
        for(i = low + 1; i <= high; i++) {
            if(Integer.parseInt(strs[i]) > root.val)
                break;
        }
        root.left = rebuild(strs, low + 1, i - 1);
        root.right = rebuild(strs, i, high);
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

4. [先序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)

```Java
class Solution {
    public TreeNode bstFromPreorder(int[] preorder) {
        return rebuild(preorder, 0, preorder.length - 1);
    }
    private TreeNode rebuild(int[] pre, int low, int high) {
        if(low > high) return null;
        TreeNode root = new TreeNode(pre[low]);
        int i;
        for(i = low + 1; i <= high; i++) {
            if(pre[i] > root.val)
                break;
        }
        root.left = rebuild(pre, low + 1, i - 1);
        root.right = rebuild(pre, i, high);
        return root;
    }
} 
```

5. [N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```Java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        LinkedList<Node> queue = new LinkedList<>();
        queue.offer(root);
        while(queue.size() > 0) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0; i < size; i++) {
                Node t = queue.poll();
                list.add(t.val);
                for(Node node : t.children)
                    if(node != null)
                        queue.offer(node);
            }
            res.add(list);
        }
        return res;
    }
}
```

6. [N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

```Java
class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Deque<Node> stack = new ArrayDeque<>();
        stack.push(root);
        while(stack.size() > 0) {
            Node cur = stack.pop();
            res.add(cur.val);
            for(int i = cur.children.size() - 1; i >= 0; i--)
                if(cur.children.get(i) != null)
                    stack.push(cur.children.get(i));
        }
        return res;
    }
}

class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        if(root == null) return res;
        help(root);
        return res;
    }
    void help(Node root) {
        if(root == null) return;
        res.add(root.val);
        for(int i = 0; i < root.children.size(); i++) {
            help(root.children.get(i));
        }
    }
}
```

7. [N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

```Java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> postorder(Node root) {
        if(root == null) return res;
        help(root);
        return res;
    }
    void help(Node root) {
        if(root == null) return;
        for(int i = 0; i < root.children.size(); i++) {
            help(root.children.get(i));
        }
        res.add(root.val);
    }
}

class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Deque<Node> stack = new ArrayDeque<>();
        stack.push(root);
        while(stack.size() > 0) {
            Node cur = stack.pop();
            res.add(cur.val);
            for(Node node : cur.children) {
                if(node != null)
                    stack.push(node);
            }
        }
        Collections.reverse(res);
        return res;
    }
}
```

8. [根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

```Java
class Solution {
    //利用前序遍历来构建Tree，然后通过后续遍历来检验当前树是否构建完毕。
    int preIndex = 0, postIndex = 0;
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        TreeNode root = new TreeNode(pre[preIndex++]);
        if(post[postIndex] != root.val) root.left = constructFromPrePost(pre, post);
        if(post[postIndex] != root.val) root.right = constructFromPrePost(pre, post);
        postIndex++;
        return root;
    }
}
```

9. [删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```Java
// 递归的一个非常重要的点就是：不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出

//函数作用：删除搜索二叉树中的key对应的节点，并保证二叉搜索树的性质不变

//输入：二叉搜索树的根节点root和一个值key

//输出：新二叉搜索的根节点的引用

//那么我们的前两步就可以直接表示为：
//root.left = deleteNode(root.left,key);
//root.right = deleteNode(root.right,key);

//对于第三步来说，有的小伙伴可能也会直接去套用，直接写成：
//root = deleteNode(root,key);

//但是这里的问题就是，deleteNode的作用就是删除二叉树的某个节点，都已经删除了，怎么又能把返回的对象再赋给他自己呢，所以对于第三步就不能这样简单的去调用了。需要自己实现

class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) return null;
        if(root.val > key) {
            root.left = deleteNode(root.left, key);
        } else if(root.val < key) {
            root.right = deleteNode(root.right, key);
        } else {
            if(root.left == null) return root.right;
            else if(root.right == null) return root.left;
            else {
                TreeNode node = root.right;
                while(node.left != null) node = node.left;
                node.left = root.left;
                return root.right;
            }
        }
        return root;
    }
}
```

## 5月11号

1. [课程表](https://leetcode-cn.com/problems/course-schedule/)

* 问题转化能力，课表选课有选修课依赖关系，拓扑排序可以解决
* 拓扑排序的实现

```Java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // indegree 记录所有课程的入度
        int[] indegree = new int[numCourses];
        
        // 二维数组记录图的有向图邻接表
        List<List<Integer>> adjacent = new ArrayList<>();
        for(int i = 0; i < numCourses; i++)
            adjacent.add(new ArrayList<Integer>());
        
        
        for(int[] adj : prerequisites) {
            indegree[adj[0]]++;
            adjacent.get(adj[1]).add(adj[0]);// 有向图
        }
        
        // 队列用来记录入度为 0 的节点，入度为 0 ，则可以出队列
        LinkedList<Integer> queue = new LinkedList<>();
        for(int i = 0; i < indegree.length; i++) {
            if(indegree[i] == 0)
                queue.add(i);
        }
        
        while(queue.size() > 0) {
            int curOut = queue.poll();
            numCourses--;
            
            // 当前出队的节点，讲它所有的邻接边消去，同时更新入度为 0 的节点
            for(int curOutAdj : adjacent.get(curOut)) {
                if(--indegree[curOutAdj] == 0)
                    queue.add(curOutAdj);
            }
        }
        return numCourses == 0;
    }
}
```

2. [排序链表](https://leetcode-cn.com/problems/sort-list/)

```Java
class Solution {
    public ListNode sortList(ListNode head) {
        return mergesort(head);
    }
    ListNode mergesort(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode midPre =  findMidPre(head);
        ListNode mid = midPre.next;
        midPre.next = null;
        ListNode left = mergesort(head);
        ListNode right = mergesort(mid);
        return merge(left,right);
    }

    ListNode findMidPre(ListNode head) {
        ListNode slow = head, fast = head, slowPre = null;
        while(fast != null && fast.next != null) {
            slowPre = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        return slowPre;
    }

    ListNode merge(ListNode A, ListNode B) {
        if(A == null || B == null) return A == null ? B : A;
        ListNode newHead = new ListNode(-1);
        ListNode p = newHead;
        while(A != null && B != null) {
            if(A.val < B.val) {
                p.next = A;
                p = p.next;
                A = A.next;
            } else {
                p.next = B;
                p = p.next;
                B = B.next;
            }
        }
        p.next = A == null ? B : A;
        return newHead.next;
    }
}
```

3. [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```Java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }

    ListNode merge(ListNode[] lists, int L, int R) {
        if(L > R) return null;
        if(L >= R) return lists[L];
        int mid = L + ((R - L) >> 1);
        ListNode left = merge(lists, L, mid);
        ListNode right = merge(lists, mid+1, R); // 归并的细节
        return mergeTwoList(left, right); // 合并两个有序链表
    }
}
```

4. [数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```Java
class Solution {
    int count;
    int[] t;
    public int reversePairs(int[] nums) {
        if(nums.length < 2) return 0;
        t = new int[nums.length];
        mergesort(nums, 0, nums.length - 1);
        return count;
    }

    public void mergesort(int[] nums, int L, int R) {
        if(L >= R) return;
        int mid = L + ((R - L) >> 1);
        mergesort(nums, L, mid);
        mergesort(nums, mid + 1, R);
        merge(nums, L, mid, R);
    }

    public void merge(int[] nums, int L, int mid, int R) {
        int index = 0, left = L, m = mid + 1;
        while(left <= mid && m <= R) {
            if(nums[left] <= nums[m]) t[index++] = nums[left++];
            else {
                t[index++] = nums[m++];
                count += (mid - left + 1);	// 终于想明白了，mid = (L + R) / 2,所以要 + 1
            }
        }
        while(left <= mid) t[index++] = nums[left++];
        while(m <= R) t[index++] = nums[m++];
        for(int i = L; i <= R; i++) {
            nums[i] = t[i - L];
        }
    }
}
```

5. [复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

* 每次回溯，路径上记录的是一个segment，需要对 segment 进行检查是否符合 ip 地址的格式
* 当 路径上有 4个 segment 就要return，如果此时 len 到了 string 的 length，则是所求结果，add进

```Java
class Solution {
    List<String> res = new ArrayList<>();
    List<String> cur = new ArrayList<>(4);
    public List<String> restoreIpAddresses(String s) {
        if(s == null || s.length() == 0) return res;
        backtrack(s, 0);
        return res;
    }

    void backtrack(String s, int len) {
        if(cur.size() == 4) {
            if(len == s.length())
                res.add(String.join(".", cur));
            return;
        }
        for(int i = 1; i <= 3; i++) {
            if(len + i > s.length()) return;
            String seg = s.substring(len, len + i);
            if((i > 1 && seg.startsWith("0")) || (i == 3 && Integer.parseInt(seg) > 255)) return;
            cur.add(seg);
            backtrack(s, len + i);
            cur.remove(cur.size() - 1);
        }
    }
}
```

## 5月12号

1. [跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

* 如果一个位置能够到达，那么这个位置左侧所有位置都能到达。

```Java
class Solution {
    public boolean canJump(int[] nums) {
        int maxDistance = 0;
        for(int i = 0; i < nums.length; i++) {
            if(i > maxDistance) return false;
            maxDistance = Math.max(maxDistance, i + nums[i]);
        }
        return true;
    }
}
```

2. [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```Java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if(strs.length == 0) return new ArrayList<>();
        Map<String, List<String>> m = new HashMap<>();
        for(String str : strs) {
            char[] c = str.toCharArray();
            Arrays.sort(c);
            String key = String.valueOf(c);
            if(!m.containsKey(key))m.put(key, new ArrayList<>());
            m.get(key).add(str);
        }
        return new ArrayList<>(m.values());
    }
}	

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if(strs.length == 0) return new ArrayList<>();
        Map<String, List<String>> m = new HashMap<>();
        int[] count = new int[26];
        for(String str : strs) {
            Arrays.fill(count, 0);
            char[] chars = str.toCharArray();
            for(char ch : chars) count[ch - 'a']++;
            StringBuilder sb = new StringBuilder();
            for(int c : count) sb.append("." + c);
            String key = sb.toString();
            if(!m.containsKey(key))m.put(key, new ArrayList<>());
            m.get(key).add(str);
        }
        return new ArrayList<>(m.values());
    }
}
```

3. [单词搜索](https://leetcode-cn.com/problems/word-search/)

```java
class Solution {
    boolean[][] v;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board[0].length == 0) return false;
        v = new boolean[board.length][board[0].length];
        for(int row = 0; row < board.length; row++) {
            for(int col = 0; col < board[row].length; col++) {
                if(dfs(board, row, col, board.length, board[0].length, 0, word)) return true;
            }
        }
        return false;
    }

    boolean dfs(char[][] board, int row, int col, int rows, int cols, int len, String target) {
        if(v[row][col] || len > target.length() || board[row][col] != target.charAt(len)) return false;
        if(len == target.length() - 1) return true;
        v[row][col] = true;
        if(row > 0 && dfs(board, row - 1, col, rows, cols, len + 1, target)) return true;
        if(row < rows - 1 && dfs(board, row + 1, col, rows, cols, len + 1, target)) return true;
        if(col > 0 && dfs(board, row, col - 1, rows, cols, len + 1, target)) return true;
        if(col < cols - 1 && dfs(board, row, col + 1, rows, cols, len + 1, target)) return true;
        v[row][col] = false;
        return false;
    }
}
```

4. [合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```Java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
        int[][] res = new int[intervals.length][2];
        int index = -1;
        for(int[] interval : intervals) {
            if(index == -1 || interval[0] > res[index][1])
                res[++index] = interval;
            else
                res[index][1] = Math.max(res[index][1], interval[1]);
        }
        return Arrays.copyOf(res, index + 1);
    }
}
```

5. [颜色分类](https://leetcode-cn.com/problems/sort-colors/)

```Java
class Solution {
    public void sortColors(int[] nums) {
        int p0 = 0, p2 = nums.length - 1;
        int cur = 0;
        while(cur <= p2) {
            if(nums[cur] == 0) swap(nums, p0++, cur++);
            else if(nums[cur] == 2) swap(nums, p2--, cur);
            else cur++;
        }
    }

    void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // public void sortColors(int[] nums) {
    //     int count0 = 0;
    //     int count1 = 0;
    //     for(int num : nums)
    //         if(num == 0) count0++;
    //         else if(num == 1) count1++;
    //     for(int i = 0; i < nums.length; i++) {
    //         if(i < count0) nums[i] = 0;
    //         else if(i >= count0 && i < count0 + count1) nums[i] = 1;
    //         else nums[i] = 2;
    //     }
    //     return;
    // }
}
```

6. [子集](https://leetcode-cn.com/problems/subsets/)

* 位运算解法，通过pow(2, n) 次运算，达到所有的子集。

```java
public List<List<Integer>> subsets(int[] nums) {
    
        List<List<Integer>> res = new ArrayList<>();
    
        for(int i = 0; i < (1 << nums.length); i++) {
            
            List<Integer> sub = new ArrayList<>();
            
            for(int j = 0; j < nums.length; j++) {
                if(((i >> j) & 1) == 1)
                    sub.add(nums[j]);
            }
            
            res.add(sub);
        }
        return res;
    }
```

* 回溯法

```Java
	List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return res;
    }
    private void backtrack(int[] nums, int len) {
        res.add(new ArrayList<>(path));
        for(int i = len; i < nums.length; i++) {
            path.add(nums[i]);
            backtrack(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
```

7. 无序数组的中位数

* 快速排序的partition, 每次判断返回的index是否等于mid

```Java
public static void main(String[] args) {
        int[] a = new int[5];
        Random random = new Random();
        for (int i = 0; i < a.length; i++) {
            a[i] = random.nextInt(100);
        }
        System.out.println(Arrays.toString(a));
        int left = 0, right = a.length - 1;
        int mid = (left + right) / 2;
        int i = -1;
        while ( i != mid) {
            i = partition(a,left,right);
            if(i < mid) left = i + 1;
            else if(i > mid) right = i - 1;
        }
        System.out.println(Arrays.toString(a));
        System.out.println(a[i]);
    }

    public static int partition(int[] nums, int left, int right) {
        int L = left, R = right;
        int pivot = nums[L];
        while (L < R) {
            while (L < R && nums[R] >= pivot) R--;
            nums[L] = nums[R];
            while (L < R && nums[L] <= pivot) L++;
            nums[R] = nums[L];
        }
        nums[L] = pivot;
        return L;
    }
```

## 5月13号

1. [单词拆分](https://leetcode-cn.com/problems/word-break/)

* 第一想法是用字典树解决问题，但是测试用例不能全过

>输入：
>
>"aaaaaaa"
>["aaaa","aaa"]
>
>输出： fasle
>
>预期结果：true

* 上面的主要原因在于，每次字典树遍历到aaa 的时候就会重新从根节点开始查找，aaa aaa a所以最后 遍历指针不是root 节点，所以输出为false

>
>
>输入：
>
>"aaaaaaa"
>["aaaa","aa"]
>
>输出：true
>
>预期：false

```Java
class Solution {
    private class TrieNode{
        private boolean end;
        private Map<Character, TrieNode> subNodes = new HashMap<>();
        
        public void addSubNode(Character key, TrieNode node) {
            subNodes.put(key, node);
        }

        TrieNode getSubNode(Character key) {
            return subNodes.get(key);
        }

        void setKeyWordEnd(boolean end) {
            this.end = end;
        }

        boolean isKeyWordEnd() {
            return end;
        }
    }
    
    private TrieNode root = new TrieNode();
    
    private void addWords(String lineText) {// 构造前缀树
        TrieNode tempNode = root;
        for (int i = 0; i < lineText.length(); i++) {
            Character c = lineText.charAt(i);
            TrieNode node = tempNode.getSubNode(c);
            if (node == null) {
                node = new TrieNode();
                tempNode.addSubNode(c, node);
            }
            tempNode = node;
            if (i == lineText.length() - 1)
                tempNode.setKeyWordEnd(true);
        }
    }
    
    public boolean wordBreak(String s, List<String> wordDict) {
        for(String str : wordDict)
            addWords(str);
        return filter(s); 
    }

    public boolean filter(String s) {
        int len = s.length();
        int position = 0;
        TrieNode temp = root;
        while(position < len) {
            char c = s.charAt(position);
            temp = temp.getSubNode(c);
            if(temp == null) return false;
            if(temp.end) temp = root;
            position++;
        }
        return position == len && temp == root;
    }
}
```

* 针对上面的问题，问题出在 filter 函数上，解决方案是用一个数组记忆字符串上每个位置的查找情况

```Java
int[] memo = new int[s.length()];
public boolean filter(String s, int left, int right) {
        if (left == right) return true;
        if (memo[left] != 0)
            return memo[left] > 0;// 递归返回
        int position = left;
        TrieNode temp = root;
        while (position < right) {
            char c = s.charAt(position);
            temp = temp.getSubNode(c);
            if (temp == null) break;
            if (temp.end && filter(s, position + 1, right)) {
                memo[left] = 1;
                return true;
            }
            position++;
        }
        memo[left] = -1;
        return false;
    }
```

* 另外一种思路，动态规划

```Java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        // dp[i] 代表字符串s的前i个字符能否拆分成wordDict
        dp[0] = true;
        Set<String> set = new HashSet<>(wordDict);
        for(int i = 1; i <= s.length(); i++) {
            for(int j = 0; j < i; j++) {
                if(dp[j] && set.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

2. [跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

```Java
class Solution {
    public boolean canJump(int[] nums) {
        int maxDistance = 0;
        for(int i = 0; i < nums.length; i++){
            if(i > maxDistance) return false;
            maxDistance = Math.max(maxDistance, i + nums[i]);
        }
        return true;
    }
}
```

3. [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```Java
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        int res = nums[0], maxDp = nums[0], minDp = nums[0];
        for(int i = 1; i < nums.length; i++) {
            int t = maxDp;
            maxDp = max(nums[i], maxDp * nums[i], minDp * nums[i]);
            minDp = min(nums[i], minDp * nums[i], t * nums[i]);
            res = Math.max(maxDp, res);
        }
        return res;
    }
    int max(int a, int b, int c){
        return Math.max(Math.max(a, b), c);
    }
    int min(int a, int b, int c){
        return Math.min(Math.min(a, b), c);
    }
}
```

4. [ 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

* 不仅仅需要找到乱序的数组，并且要检查乱序数组两侧的数值，有没有在此乱序数组的值之间的数

```Java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        if(nums.length < 2) return 0;
        int l = 0, r = nums.length - 1;
        while(l < r && nums[l] <= nums[l + 1]) l++;
        while(l < r && nums[r] >= nums[r - 1]) r--;
        if(l == r) return 0;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(int i = l; i <= r; i++){
            min = Math.min(nums[i], min);
            max = Math.max(nums[i], max);
        }
        for(int i = 0; i <= l; i++) {
            if(nums[i] > min){
                l = i;
                break;
            }
        }
        for(int i = nums.length - 1; i >= r; i--) {
            if(nums[i] < max) {
                r = i;
                break;
            }
        }
        return r - l + 1;
    }
}
```

5. [构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

```Java
class Solution {
    public int[] constructArr(int[] nums) {
        int len = nums.length;
        if(len == 0) return new int[0];
        int[] left = new int[len];
        int[] right = new int[len];
        left[0] = nums[0];
        right[len - 1] = nums[len - 1];
        for(int i = 1; i < len; i++) {
            left[i] = left[i - 1] * nums[i];
            right[len - i - 1] = right[len - i] * nums[len - i - 1];
        }
        int[] res = new int[len];
        res[0] = right[1];
        res[len - 1] = left[len - 2];
        for(int i = 1; i < len - 1; i++) {
            res[i] = left[i - 1] * right[i + 1];
        }
        return res;
    }
}
```

## 5月14号

1. [相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

![](https://github.com/Wayne-98/image/blob/master/Algorithms/May/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png?raw=true)

```Java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA, b = headB;
        while(a != b) {
            a = (a != null) ? a.next : headB;
            b = (b != null) ? b.next : headA;
        }
        return a;
    }
}

//下面的解法是错误的，因为每次遍历到空的时候，应该回到另一个链表的表头，而不是运动着的headB;
/**
public class Solution{
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    	while(headA != headB) {
            headA = (headA != null) ? headA.next : headB;
            headB = (headB != null) ? headB.next : headA;
        }
        return headA;
    }
}
*/
```

2. [多数元素](https://leetcode-cn.com/problems/majority-element/)

* 打仗的思想，我方先上一个人，对方来就干掉一个人，最后活下来的那个人就是超过半数的。当然有可能有趁机最后溜上去的，题目说明一定会有半数的，所以没有检查。如果出现没有半数的这种情况，最后检查一下就okk

```Java
class Solution {
    public int majorityElement(int[] nums) {
        int res = nums[0];
        int count = 1;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] == res) count++;
            else {
                if(--count == 0) {
                    res = nums[i];
                    count = 1;
                }
            }
        }
        return res;
    }
}
```

3. [求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

* 上一题的升级版，用投票想法来解决问题。

```Java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList<>();
        if(nums.length == 0) return res;
        int candidate1 = nums[0], count1 = 0;
        int candidate2 = nums[0], count2 = 0;
        for(int num : nums) {
            if(num == candidate1) {
                count1++;
                continue;
            }
            if(num == candidate2) {
                count2++;
                continue;
            }
            // 既不等于候选人1，也不等于候选人2
            
            // 此刻如果候选人1已经是0了，那么就让当前值做候选人1
            if(count1 == 0) {
                candidate1 = num;
                count1 = 1;
                continue;
            }
            // 如果此刻候选人1不为零，候选人2为零，那么就让当前值做候选人2
            if(count2 == 0) {
                candidate2 = num;
                count2 = 1;
                continue;
            }

            //如果此刻候选人１,２　都不为０，那么都让他们--;
            count1--;count2--;
        }
        count1 = 0;
        count2 = 0;
        for(int num : nums) {
            if(num == candidate1) count1++;
            else if(num == candidate2) count2++;// else if : 如果两个candidate的值相同，不是else if 会导致结果重复。
        }
        if(count1 > nums.length / 3) res.add(candidate1);
        if(count2 > nums.length / 3) res.add(candidate2);
        return res;
    }
}
```

4. [只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```Java
class Solution {
    public int singleNumber(int[] nums) {
        int all = 0;
        for(int num : nums)
            all ^= num;
        return all;
    }
}
```

5. [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

* 思路1，用一个最小堆遍历一遍数组

```Java
    public int findKthLargest(int[] nums, int k) {
        if(nums.length == 0 || k > nums.length) return 0;
        // PriorityQueue<Integer> minHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
        
        // 默认是最小堆
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for(int i = 0; i < k; i++) minHeap.offer(nums[i]);
        for(int i = k; i < nums.length; i++) {
            if(nums[i] > minHeap.peek()) {
                minHeap.poll();
                minHeap.offer(nums[i]);
            }
        }
        // while(minHeap.size() != 1) minHeap.poll();
        return minHeap.peek();
    }
```

* 思路2，快排partition，定位置为 nums.length - k

```java
public int findKthLargest(int[] nums, int k) {
        if(nums.length == 0 || k > nums.length) return 0;
        int index = -1;
        int left = 0, right = nums.length - 1;
        while(index != nums.length - k) {
            index = partition(nums, left, right);
            if(index > nums.length - k) right = index - 1;
            else if(index < nums.length - k) left = index + 1;
        }
        return nums[index];
    }
    int partition(int[] nums, int left, int right) {
        int L = left, R = right;
        int pivot = nums[L];
        while(L < R) {
            while(L < R && nums[R] >= pivot) R--;
            nums[L] = nums[R];
            while(L < R && nums[L] <= pivot) L++;
            nums[R] = nums[L];
        }
        nums[L] = pivot;
        return L;
    }
```

* 手写个最小堆来

* 用文本编辑器，手写一个最小堆一次 AC 的感觉真开心啊 O(∩_∩)O~~

```Java
public int findKthLargest(int[] nums, int k) {
    if(nums.length == 0 || k > nums.length) return 0;
    int[] minHeap = new int[k+1];// 0处为哨兵，让代码更简洁
    for(int i = 0; i < k; i++) minHeap[i+1] = nums[i];
    buildMinHeap(minHeap);
    for(int i = k; i < nums.length; i++) {
        if(nums[i] > minHeap[1]) {
            minHeap[1] = nums[i];
            adjustDown(minHeap, 1, minHeap.length);
        }
    }
    return minHeap[1];
}

public void buildMinHeap(int[] nums) {
    for(int i = nums.length / 2; i > 0; i--)
        adjustDown(nums, i, nums.length);
}

public void adjustDown(int[] nums, int k, int len) {
    nums[0] = nums[k];
    for(int i = k * 2; i < len; i *= 2) {
        if(i < len - 1 && nums[i + 1] < nums[i]) i++;
        if(nums[i] >= nums[0]) break;
        else {
            nums[k] = nums[i];
            k = i;
        }
    }
    nums[k] = nums[0];
}
```

6. [回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```Java
class Solution {
    int res = 0;
    public int countSubstrings(String s) {
        for(int i = 0; i < s.length(); i++) {
            expand(s, i, i);
            expand(s, i, i+1);
        }
        return res;
    }
    void expand(String s, int left, int right) {
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            res++;
            left--;
            right++;
        }
    }
}
```

7. [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```Java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() == 0) return "";
        int left = 0, right = 0;
        for(int i = 0; i < s.length(); i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i+1);
            int len = Math.max(len1, len2);
            if(len > (right - left)) {
                left = i - (len - 1) / 2;
                right = i + len / 2;
            }
        }
        return s.substring(left, right + 1);
    }
    int expand(String s, int left, int right) {
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    
}
```

8. [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

* 仔细审题，这只是一道简单的 DFS BFS 题目

```Java
class Solution {
    boolean[][] v;
    public int numIslands(char[][] grid) {
        if(grid.length == 0 || grid[0].length == 0) return 0;
        v = new boolean[grid.length][grid[0].length];
        int count = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(!v[i][j] && grid[i][j] != '0') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    public void dfs(char[][] grid, int row, int col) {
        if(row < 0 || row == grid.length || col < 0 || col == grid[0].length || v[row][col] || grid[row][col] == '0') return;
        v[row][col] = true;
        dfs(grid, row - 1, col);
        dfs(grid, row + 1, col);
        dfs(grid, row, col - 1);
        dfs(grid, row, col + 1);
    }
}
```

* 以下是 BFS 解法，要注意每次入队的时候，要讲此节点标记为已访问

```Java
class Solution {
    boolean[][] v;
    public int numIslands(char[][] grid) {
        if(grid.length == 0 || grid[0].length == 0) return 0;
        v = new boolean[grid.length][grid[0].length];
        int count = 0;
        for(int row = 0; row < grid.length; row++) {
            for(int col = 0; col < grid[0].length; col++) {
                if(!v[row][col] && grid[row][col] == '1') {
                    count++;
                    LinkedList<Integer> q = new LinkedList<>();
                    q.offer(row);
                    q.offer(col);
                    v[row][col] = true;
                    while(q.size() > 0) {
                        int currow = q.poll();
                        int curcol = q.poll();
                        if(check(grid, currow - 1, curcol)) {
                            q.offer(currow - 1);
                            q.offer(curcol);
                            v[currow - 1][curcol] = true;
                        }
                        if(check(grid, currow + 1, curcol)) {
                            q.offer(currow + 1);
                            q.offer(curcol);
                            v[currow + 1][curcol] = true;
                        }
                        if(check(grid, currow, curcol - 1)) {
                            q.offer(currow);
                            q.offer(curcol - 1);
                            v[currow][curcol - 1] = true;
                        }
                        if(check(grid, currow, curcol + 1)) {
                            q.offer(currow);
                            q.offer(curcol + 1);
                            v[currow][curcol + 1] = true;
                        }
                    }
                }
            }
        }
        return count;
    }

    boolean check(char[][] grid, int row, int col) {
        if(row < 0 || row == grid.length || col < 0 || col == grid[0].length || v[row][col] || grid[row][col] == '0') return false;
        return true;
    }
}
```

## 5月15号

1. [和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

* 暴力遍历解法，对于每个子数组都判断一次是否和为k

```Java
public int subarraySum(int[] nums, int k) {
        int count = 0;
        for(int i = 0; i < nums.length; i++) {
            int sum = 0;
            for(int j = i; j < nums.length; j++) {
                sum += nums[j];
                if(sum == k) count++;
            }
        }
        return count;
    }
```

* 引入前缀和数组概念

```Java
	public int subarraySum(int[] nums, int k) {
        int[] prefixSum = new int[nums.length + 1];
        prefixSum[0] = 0;
        for(int i = 0; i < nums.length; i++){
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        int count = 0;
        for(int i = 0; i < nums.length; i++) {
            for(int j = i; j < nums.length; j++) {
                if(prefixSum[j + 1] - prefixSum[i] == k)
                    count++;
            }
        }
        return count;
    }
```

* HashMap 优化前缀和数组

```Java
public int subarraySum(int[] nums, int k) {
        Map<Integer,Integer> m = new HashMap<>();
        // key 保存的是前缀和的值
        // val 保存的是前缀和的出现的次数
        m.put(0, 1);
        int count = 0;
        int prefixSum = 0;
        for(int num : nums) {
            prefixSum += num;
            if(m.containsKey(prefixSum - k)) count += m.get(prefixSum - k);
            if(m.containsKey(prefixSum)) {
                int val = m.get(prefixSum);
                m.put(prefixSum, val+1);
            } else
                m.put(prefixSum, 1);
        }
        return count;
    }
```

2. [移动零](https://leetcode-cn.com/problems/move-zeroes/)

```Java
class Solution {

    public void moveZeroes(int[] nums) {
        int i = 0;
        for(int j = 0; j < nums.length; j++) {
            if(nums[j] != 0) {
                int t = nums[i];
                nums[i] = nums[j];
                nums[j] = t;
                i++;
            }
        }
    }

    // public void moveZeroes(int[] nums) {
    //     int indexOfNotZero = 0;
    //     for(int i = 0; i < nums.length; i++)
    //         if(nums[i] != 0)
    //             nums[indexOfNotZero++] = nums[i];
        
    //     for(int i = indexOfNotZero; i < nums.length; i++)
    //         nums[i] = 0;
    //     return;
    // }
}
```

3. [最大正方形](https://leetcode-cn.com/problems/maximal-square/)

![](https://pic.leetcode-cn.com/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png)

```Java
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix.length == 0 || matrix[0].length == 0) return 0;
        int max = 0;
        int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];
        for(int row = 0; row < matrix.length; row++) {
            for(int col = 0; col < matrix[0].length; col++) {
                if(matrix[row][col] == '1') {
                    dp[row+1][col+1] = Math.min(Math.min(dp[row][col], dp[row+1][col]),dp[row][col+1]) + 1;
                    max = Math.max(max, dp[row+1][col+1]);
                }
            }
        }
        return max * max;
    }
}
```

* dp(i + 1, j + 1) 表示的是 以matr(i, j) 为右下角的最大正方形的边长
* 这个最大正方形的边长受到其上，左，左上的最大正方形边长的限制

4. [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```Java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        dp[0] = 0;
        for(int i = 1; i <= n; i++) {
            dp[i] = i;
            for(int j = 1; j * j <= i; j++)
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
        return dp[n];
    }
}
```

## 5月16号

1. [K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        
        ListNode newHead = new ListNode(-1);
        newHead.next = head;
        
        ListNode pre = newHead, end = newHead;
        
        while(end != null){
            
            for(int i = 0; i < k && end != null; i++) end = end.next;
            if(end == null) break;
            
            ListNode start = pre.next;//待翻转子链表的头结点
            ListNode next = end.next;//保存下一个带翻转链表
            
            end.next = null;
            pre.next = reverseList(start);
            
            start.next = next;//翻转后，start是最后一个节点，将已翻转的链接和待翻转的链接接上
            
            pre = start; // 更新pre 和 end
            end = start; 
        }
        return newHead.next;
    }
    
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode newHead = new ListNode(-1);
        ListNode p = head, r = p.next;
        while(p != null){
            r = p.next;
            p.next = newHead.next;
            newHead.next = p;
            p = r;
        }
        return newHead.next;
    }
}
```

2. [除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

* 我的解法

```Java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        if(nums.length < 2) return new int[0];
        int len = nums.length;
        int[] left = new int[len];
        int[] right = new int[len];
        left[0] = nums[0];
        right[len - 1] = nums[len - 1];
        for(int i = 1; i < nums.length; i++) {
            left[i] = left[i - 1] * nums[i];
            right[len - i - 1] = right[len - i] * nums[len - i - 1]; 
        }
        int[] res = new int[len];
        res[0] = right[1];
        res[len - 1] = left[len - 2];
        for(int i = 1; i < len - 1; i++) {
            res[i] = left[i - 1] * right[i + 1];
        }
        return res;
    }
}
```

* 大佬的解法，十分巧妙

```Java
public int[] productExceptSelf(int[] nums){
        if(nums.length < 2) return new int[0];
        int len = nums.length;
        int[] res = new int[len];
        int k = 1;
        for(int i = 0; i < len; i++) {
            res[i] = k;
            k *= nums[i];// 此时数组存储的是除去当前元素左边的元素乘积
        }
        k = 1;
        for(int i = len - 1; i >= 0; i--) {
            res[i] *= k;
            k *= nums[i];
        }
        return res;
    }
```

3. [1～n整数中1出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

```Java
class Solution {
    public int countDigitOne(int n) {
        return f(n);
    }
    int f(int n){
        if(n <=0) return 0;
        String s = String.valueOf(n);
        int high = s.charAt(0) - '0';
        int pow = (int)Math.pow(10,s.length()-1);
        int last = n - high * pow;
        // 例如 1234 -> 1 ~ 999 1000 ~ 1234
        // f(pow - 1) 999中出现1的个数
        // last + 1 千分位为1的个数
        // f(last) 234中出现1的个数
        if(high==1) return f(pow - 1) + f(last) + last + 1;

        // 例如3234 -> 1 ~ 999 1000 ~ 1999 2000 ~ 2999 3000 ~ 3234
        // 1 ~ 999 f(pow - 1)
        // 1000 ~ 1999 f(pow - 1) + pow
        // 2000 ~ 2000 f(pow - 1)
        // 3000 ~ 3234 f(last)
        else return high * f(pow - 1) + f(last) + pow;
    }
}
```

3. [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

* DP 问题
* **状态定义：**由于一个子序列一定会以一个数进行结尾，所以我们定义`dp[i]` 表示以 `nums[i]` 结尾的**上升子序列**
* **状态转移：**
  1. 遍历到`nums[i]`的时候，需要扫描 `i` 之前的所有的`nums`值
  2. 只要 `nums[i]` 严格大于在它位置之前的某个数，那么 `nums[i]` 就可以接在这个数后面形成一个更长的上升子序列；
  3. 因此，`dp[i]` 就等于下标 `i` 之前**严格**小于 `nums[i]` 的状态值的最大者 +1。

* **初始状态：**每个数字都可以看做一个上升子序列，所以`dp`数组初始值全部赋值为1

* **考虑输出：**需要的是全局的最长子序列，所以是dp数组的最大值。

* **考虑状态压缩：**遍历到一个新数的时候，之前所有的状态值都得保留，因此无法压缩。

```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length < 2) return nums.length;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        for(int i = 1; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        int res = dp[0];
        for(int i = 1; i < nums.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

* 另一种解法
* **状态定义：** `tail[i]` 定义的是长度为 `i+1` 的最长上升子序列的结尾的最小值
* **状态转移：**
  1. 在遍历数组 `nums` 的过程中，每来一个新数 `num`，如果这个数**严格**大于有序数组 `tail` 的最后一个元素，就把 `num` 放在有序数组 `tail` 的后面
  2. 否则，在有序数组 `tail` 中查找第 1 个等于大于 `num` 的那个数，试图让它变小；

- **初始状态：**`dp[0] = nums[0]`，在只有 1 个元素的情况下，它当然是长度为 1 并且结尾最小的元素。

- **考虑输出：**`tail`数组的长度

- **考虑状态压缩：**无法压缩。

```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length < 2) return nums.length;
        int[] tail = new int[nums.length];
        // tail[i] 定义的是长度为 i+1 的最长上升子序列的最小值
        tail[0] = nums[0];
        int res = 1;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > tail[res-1]) tail[res++] = nums[i];
            // 0~res 中找到第一个比 nums[i] 大于等于的数字
            else {
                int index = find(tail, 0, res, nums[i]);
                tail[index] = nums[i];
            }
        }
        return res;
    }

    public int find(int[] nums, int l, int r, int target){
        while(l <= r) {
            int mid = l + ((r - l) >> 1);
            if(nums[mid] == target) return mid;
            else if(nums[mid] > target) r = mid - 1;
            else l = mid + 1;
        }
        return l;
    }
}
```

4. [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```Java
public int maxSubArray(int[] nums) {
        // dp 数组 dp[i] 定义为遍历到当前 num 时子数组的最大值，那么最后的结果就是 dp 数组的最大值
        // 如果dp[i-1] 小于等于0 那我放弃前面的重新开始，否则加上前面的
        // 初始化dp[0] = nums[0];

        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.length; i++) {
            dp[i] = (dp[i - 1] <= 0) ? nums[i] : (dp[i - 1] + nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```

```Java
public int maxSubArray(int[] nums) {
        if(nums.length == 0) return 0;
        int res = nums[0];
        int pre = nums[0];
        for(int i = 1; i < nums.length; i++) {
            pre = pre <= 0 ? nums[i] : nums[i] + pre;
            res = Math.max(res, pre);
        }
        return res;
    }
```

5. [寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

```Java
class Solution {
    public int findDuplicate(int[] nums) {
        for(int i = 0; i < nums.length; i++) {
            while(nums[i] != (i + 1)){
                if(nums[i] == nums[nums[i] - 1]) return nums[i];
                swap(nums, i, nums[i] - 1);
            }
        }
        return -1;
    }
    void swap(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}// 不符合题意，因为题目说明原数组是只读的
```

* 用二分法定位在一个区间里的整数(抽屉原理)
* 抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。

```Java
class Solution {
    public int findDuplicate(int[] nums) {
        int L = 1, R = nums.length - 1;
        while(L < R) {
            int mid = L + ((R - L) >> 1);
            int count = 0;
            for(int num : nums) {
                if(num <= mid)
                    count++;
            }
            // 小于等于 4 的个数 如果严格大于 4
            // 此时重复元素一定在[1, 4]之间
            if(count > mid) R = mid;
            else L = mid + 1;
        }
        return L;
    }
}
```

6. [缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

```Java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for(int i = 0; i < nums.length; i++) {
            // i 和 nums[i] - 1
            //满足在指定范围内、并且没有放在正确的位置上，才交换
            while(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){
                swap(nums, i, nums[i] - 1);
            }
        }
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] != (i+1))
                return i+1;
        }
        return nums.length + 1;
    }
    void swap(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

