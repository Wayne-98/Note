## 5月2号

1. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || in.length == 0 || pre.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                root.right = buildTree(Arrays.copyOfRange(pre,i+1,pre.length), Arrays.copyOfRange(in, i+1, in.length));
            }
        }
        return root;
    }
}
```

* 解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来

2. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        // if() return false;
        ListNode mid = findMid(head);
        ListNode reverse = reverseList(mid);
        while(head != mid) {
            if(head.val != reverse.val) return false;
            head = head.next;
            reverse = reverse.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head) {
        ListNode newHead = new ListNode(-1);
        ListNode t = null;
        while(head != null) {
            t = head.next;
            head.next = newHead.next;
            newHead.next = head;
            head = t;
        }
        return newHead.next;
    }
    ListNode findMid(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

