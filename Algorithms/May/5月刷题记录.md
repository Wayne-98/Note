## 5月2号

1. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || in.length == 0 || pre.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                root.right = buildTree(Arrays.copyOfRange(pre,i+1,pre.length), Arrays.copyOfRange(in, i+1, in.length));
            }
        }
        return root;
    }
}
```

* 解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来

2. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        // if() return false;
        ListNode mid = findMid(head);
        ListNode reverse = reverseList(mid);
        while(head != mid) {
            if(head.val != reverse.val) return false;
            head = head.next;
            reverse = reverse.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head) {
        ListNode newHead = new ListNode(-1);
        ListNode t = null;
        while(head != null) {
            t = head.next;
            head.next = newHead.next;
            newHead.next = head;
            head = t;
        }
        return newHead.next;
    }
    ListNode findMid(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

## 5月3号

1. [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```Java

class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || pre.length == 0 || in.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                root.right = buildTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return root;
    }
}
```

2. [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```Java
class Solution {
    boolean[][] v;
    char[] c;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board[0].length == 0) return false;
        v = new boolean[board.length][board[0].length];
        c = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, i, j, 0)) return true;
            }
        }
        return false;
    }

    boolean dfs(char[][] board, int row, int col, int len) {
        if(v[row][col] || board[row][col] != c[len]) return false;
        if(len == c.length - 1) return true; 
        v[row][col] = true;
        if(row > 0 && dfs(board, row - 1, col, len + 1)) return true;
        if(row < board.length - 1 && dfs(board, row + 1, col, len + 1)) return true;
        if(col > 0 && dfs(board, row, col - 1, len + 1)) return true;
        if(col < board[0].length - 1 && dfs(board, row, col + 1, len + 1)) return true;
        v[row][col] = false;
        return false;
    }
}	
```

3. [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```Java
class Solution {
    boolean[][] v;
    int threshold;
    public int movingCount(int m, int n, int k) {
        v = new boolean[m][n];
        threshold = k;
        return dfs(m,n,0,0);
    }
    int dfs(int rows, int cols, int row, int col) {
        int count = 0;
        if(row < rows && col <cols && sum(row) + sum(col) <= threshold && !v[row][col]){
            v[row][col] = true;
            count = 1 + dfs(rows, cols, row + 1, col) + dfs(rows, cols, row, col + 1);
        }
        return count;
    }
    int sum(int n) {
        int sum = 0;
        while(n > 0){
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
}
```

* 还需要再复习一下

## 5月4号

1. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```Java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() < 1) return "";
        int left = 0, right = 0;
        for(int i = 0; i < s.length() - 1; i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if(len > (right - left + 1)) {
                left = i - (len - 1) / 2;// 注意此处是 len - 1
                right = i + len / 2;
            }
        }
        return s.substring(left, right + 1);
    }

    private int expand(String s, int i, int j) {
        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {
            i--; j++;
        }
        return j - i - 1;
    }
}
```

2. [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```java
class Solution {
    public int myAtoi(String str) {
        if(str.length() == 0) return 0;
        int index = 0, res = 0;
        while(index < str.length() && str.charAt(index) == ' ') index++;
        if(index == str.length()) return 0;
        boolean positive = true;
        char fristChar = str.charAt(index);
        if(!isNum(fristChar)) {
            if(fristChar != '+' && fristChar != '-') return 0;
            positive = (fristChar != '-');
            index++;
        }
        int limit = positive ? -Integer.MAX_VALUE : Integer.MIN_VALUE;
        while(index < str.length() && isNum(str.charAt(index))) {
            int t = str.charAt(index++) - '0';
            // 如果 res * 10 - t 越界, 那么 res * 10 - t < limit
            if(res < (limit + t) / 10) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 - t;
        }

        return positive ? -res : res;
    }
    private boolean isNum(char c) {
        int t = c - '0';
        if(t >= 0 && t <= 9) return true;
        return false;
    }
}
```

