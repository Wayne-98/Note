* 封锁协议：

1. 一级封锁协议：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。（解决了丢失修改）
2. 二级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。（解决了 读“脏”数据）
3. 三级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。（解决了不可重复读）

* 活锁：类似于操作系统“饿死进程”的情况，解决方案 先来先服务
* 死锁：



* 并发调度的可串行性：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度。

  可串行化是并发事务正确调度的准则。



* 两段锁协议：所有事务必须分两个阶段对数据项进行加锁和解锁
  * 在对任何数据进行读、写之前，首先要申请并获得对该数据的封锁
  * 在释放一个封锁之后，事务不再申请和获得任何其他封锁。



事务遵守两段锁协议是可串行化调度的充分不必要条件。

