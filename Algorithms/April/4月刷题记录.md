# 4月刷题记录
## 4月11日刷题记录
**1. [连续子数组的最大和](
https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)**
* dp问题
很容易就看出需要用dp来解，但是没有想出来状态转移方程。因为没有考虑到最后一步的解和前一步的解，他们之间的关系

**2. [两数相加](
https://leetcode-cn.com/problems/add-two-numbers/)**
* 链表
* 初始想法
拿到题目先想到遍历链表取出值，然后得到和，在new一个新链表返回。但是int会溢出
* 别人的解
因为链表记录的数字是反序的，正好和10进制相加进位相同，所以直接相加并记录进位就可以

**3.[无重复字符的最长子串](
https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)**
* 滑动窗口
    每次前进一位向前看有没有重复字符，选择方式有：遍历，用一个Set记录，用HashMap，key记录用来记录字符有没有重复，value用来保存下标，如果重复直接更新下标值就可以
* 之前做过所以知道用HashMap来存储下标索引
***
## 4月12日刷题记录
1. **[在排序数组中查找元素的第一个和最后一个位置](
https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)**
* 二分查找，找左右端点问题，之前做过，复习一下。顺利写出
2. **[寻找两个有序数组的中位数](
https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)**
* 二分查找
    * 大概思想看懂了，很多细节真看不懂。日后再看看吧，花了很多时间
    
3. **[最长回文子串](
https://leetcode-cn.com/problems/longest-palindromic-substring/)**
* 中心扩展法
    * 拿到题没有想法，看解析看了这种解法比较容易接受。
    
    ***
    
## 4月13日刷题记录
1. **[盛最多水的容器](
https://leetcode-cn.com/problems/container-with-most-water/)**
* 看解析
2. **[三数之和](
https://leetcode-cn.com/problems/3sum/)**
* 看解析
    * **[两数之和](
https://leetcode-cn.com/problems/two-sum/)**
    * 拿到题想到暴力解法，但是没想到如何优化。这种需要考虑数组下标的，很好的优化方法是利用哈希表存储下标。
3. **[电话号码的字母组合](
https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)**
* 字符串
* 回溯
    暴力dfs搜索
***
## 4月14日刷题记录

1. **[有效的括号](
https://leetcode-cn.com/problems/valid-parentheses/)**
* 考研的时候做过，AC
2. **[合并两个有序链表](
https://leetcode-cn.com/problems/merge-two-sorted-lists/)**
* 考研的时候做过，AC
3. **[最大子序和](
https://leetcode-cn.com/problems/maximum-subarray/)**
* dp解法之前写过，AC
* 分治法没咋看懂，不看了
* 贪心算法(再看一下吧)
4. **[爬楼梯](
https://leetcode-cn.com/problems/climbing-stairs/)**
* 斐波那契数列
* dp
5. **[]()**
## 4月15刷题记录
1. [至少有K个重复字符的最长子串](
https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)
* 拿到题目没有思路，看了大佬的分治法看懂了。

2. [最长公共前缀](
https://leetcode-cn.com/problems/longest-common-prefix/)
* 暴力解法，优化的答案没咋看懂，而且优化的答案时间复杂度也不低
3. [字符串的排列](
https://leetcode-cn.com/problems/permutation-in-string/)
* 问题转化能力，将题目的抽象转化为算法容易实现的点
* 滑动窗口
## 4月16刷题记录
1. [字符串相乘](
https://leetcode-cn.com/problems/multiply-strings/submissions/)
* 模拟乘法
![6a3cc30cec8ae4c92137eaacce74582d.png](en-resource://database/1323:1)
2. [翻转字符串里的单词](
https://leetcode-cn.com/problems/reverse-words-in-a-string/)
* 正则表达式，调API AC
3. [简化路径](
https://leetcode-cn.com/problems/simplify-path/)
* 每一次出现“..”都要考虑上一次的内容，所以可以采用栈这个数据结构存储上次的结果
* 直接从后往前遍历，然后用一个count记录“..”的出现次数
4. [复原IP地址](
https://leetcode-cn.com/problems/restore-ip-addresses/)
* 回溯

## 4月17刷题记录
* 复习
[]在排序数组中查找元素的第一个和最后一个位置
[]三数之和 两数之和
[]电话号码的字母组合
[]至少有K个重复字符的最长子串
[]字符串相乘
[]复原IP地址

## 4月18刷题记录
1. [复原IP地址](
https://leetcode-cn.com/problems/restore-ip-addresses/)
    * 重新写了一次
2. [排序链表](
https://leetcode-cn.com/problems/sort-list/)
    * 思路是对的，实现的细节和数组归并还是有差别。需要好好感悟一下
 3. [反转链表](
https://leetcode-cn.com/problems/reverse-linked-list/)
    * AC
4. [相交链表](
https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)
    * 之前写过，但是有细节没有把握好
5. [环形链表](
https://leetcode-cn.com/problems/linked-list-cycle/)
    * 还是有挺多细节要注意
6. [环形链表 II](
https://leetcode-cn.com/problems/linked-list-cycle-ii/)
    * AC(细节要注意)
## 4月19刷题记录
1. [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
* 拿到手的思路是两两排序，看了大佬的归并解法，理解并实现
2. [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
* AC
3. [二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/submissions/)
* AC
4. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
* 中序遍历保存二叉搜索树的值，访问
* 在前序遍历方法中加上参数
5. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)
* 非递归
6. [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
7. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)
## 4月20刷题记录
1. [字符串转整数](https://leetcode-cn.com/problems/string-to-integer-atoi/)
* 太多细节

##  4月21刷题记录
1. [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
2. [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
3. [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
4. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

* 非递归又写了一下

5. [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

* 很巧妙的解法：二分查找

## 4月23日上午
1. [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
2. [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
3. [数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)
4. [旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)
5. [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

## 4月24日

1. [数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

   * AC

   ```Java
   class Solution {
       int count;
       int[] t;
       public int reversePairs(int[] nums) {
           if(nums.length < 2) return 0;
           t = new int[nums.length];
           sort(nums);
           return count;
       }
       void sort(int[] nums){
           sort(nums,0,nums.length-1);
       }
       void sort(int[] nums, int left, int right){
           if(left >= right) return;
           int mid = left + ((right - left) >> 1);
           sort(nums,left,mid);
           sort(nums,mid+1,right);
           merge(nums,left,mid,right);
       }
       void merge(int[] nums, int left, int mid, int right) {
           int L = left, R = mid+1;
           int index = left;
           while(L <= mid && R <= right) {
               if(nums[L] <= nums[R]) t[index++] = nums[L++];
               else {
                   t[index++] = nums[R++];
                   count += (mid - L + 1);
               }
           }
           while(L <= mid) t[index++] = nums[L++];
           while(R <= right) t[index++] = nums[R++];
           for(int i = left; i <= right; i++){
               nums[i] = t[i];
           }
       }
   }
   ```

2. [排序链表](https://leetcode-cn.com/problems/sort-list/)

   * 每日一题是数组归并，所以想起来之前自己写的一道链表归并

   ```Java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode sortList(ListNode head) {
           return sort(head);
       }
       
       ListNode sort(ListNode head) {
           if(head == null || head.next == null) return head;
           ListNode t = getMid(head);
           ListNode mid = t.next;
           t.next = null;
           ListNode left = sort(head);
           ListNode right = sort(mid);
           return merge(left,right);
       }
   	//返回的是mid节点的前一个节点
       //是为了方便置链表的尾节点为空
       ListNode getMid(ListNode head) {
           if(head == null || head.next == null) return head;
           ListNode t = head;
           ListNode slow = head;
           ListNode fast = head;
           while(fast != null && fast.next != null) {
               t = slow;
               slow = slow.next;
               fast = fast.next.next;
           }
           return t;
       }
   
       ListNode merge(ListNode p1, ListNode p2) {
           if(p1 == null) return p2;
           if(p2 == null) return p1;
           ListNode newHead = new ListNode(-1);
           ListNode p = newHead;
           while(p1 != null && p2 != null) {
               if(p1.val < p2.val){
                   p.next = p1;
                   p = p.next;
                   p1 = p1.next;
               } else {
                   p.next = p2;
                   p = p.next;
                   p2 = p2.next;
               }
           }
           while(p1 != null){
                p.next = p1;
                   p = p.next;
                   p1 = p1.next;
           }
           while(p2 != null){
               p.next = p2;
               p = p.next;
               p2 = p2.next;
           }
           p.next = null;
           return newHead.next;
       }
   }
   ```

   

3. [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

   * 拿到题目后，第一想法是暴力枚举所有可能的序列，然后用 isValid 函数判定，但是总是有个 bug，也没搞明白为什么，放弃

   * 括号匹配，可以转化问题为 --> 左括号的数目和右括号的数目 --> 左括号可以使用的数目要大于0 --> 每次使用一个右括号，那么必须先使用一次左括号 --> 左括号可以使用的数目恒小于右括号可以使用的数目

     ```Java
     class Solution {
         List<String> res = new ArrayList<>();
         StringBuilder path = new StringBuilder();
         public List<String> generateParenthesis(int n) {
             if(n == 0) return res;
             dfs(n,n);
             return res;
         }
         /**
          * @param left 当前左括号还有几个可以使用
          * @param right 同上
          */
         void dfs(int left, int right) {
             if(left == 0 && right == 0){
                 res.add(path.toString());
                 return;
             }
             if(left > right) return; // 左括号可以使用的个数严格小于右括号可以使用的个数
             if(left > 0) {
                 path.append("(");
                 dfs(left - 1, right);
                 path.deleteCharAt(path.length() - 1);
             }
             if(right > 0) {
                 path.append(")");
                 dfs(left,right-1);
                 path.deleteCharAt(path.length() - 1);
             }
         }
     }
     ```

     

4. [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

   * 归并排序 AC

   ```Java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) { val = x; }
    * }
    */
   class Solution {
       public ListNode mergeKLists(ListNode[] lists) {
           return mergeSort(lists,0,lists.length-1);
       }
   
       ListNode mergeSort(ListNode[] lists, int left, int right) {
           if(left >= right) return null;
           int mid = left + ((right - left) >> 1);
           ListNode L =  mergeSort(lists, left, mid);
           ListNode R =  mergeSort(lists, mid + 1, right);
           return mergeTwoLists(L,R);
       }
       // 合并两个有序链表的API
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
               if(l1 == null && l2 == null) return null;
               if(l1 == null) return l2;
               if(l2 == null) return l1;
               ListNode newHead = new ListNode(-1);
               ListNode p = newHead;
               while(l1 != null && l2 != null){
                   if(l1.val < l2.val) {
                       p.next = l1;
                       p = p.next;
                       l1 = l1.next;
                   } else {
                       p.next = l2;
                       p = p.next;
                       l2 = l2.next;
                   }
               }
               while(l1 != null) {
                   p.next = l1;
                   p = p.next;
                   l1 = l1.next;
               }
               while(l2 != null) {
                   p.next = l2;
                   p = p.next;
                   l2 = l2.next;
               }
               p.next = null;
               return newHead.next;
           }
   }
   ```

   * 看题解还可以使用堆解决，所以复习一下堆排序。

   ```Java
   // 手写堆排序
   package LeetCode;
   
   import java.util.Arrays;
   
   public class HeapSort {
   
       public static void main(String[] args) {
           int[] n = {0, 8, 9, 7, 15, 3, 1, 11, 12, 20, 19};
           heapSort(n);
           System.out.println(Arrays.toString(n));
       }
   
       static void heapSort(int[] nums) {
           buildMaxHeap(nums);
           for (int i = nums.length - 1; i > 1; i--) {
               swap(nums, i, 1);
               adjustDown(nums, 1, i);
           }
       }
   
       static void buildMaxHeap(int[] nums) {
           for (int i = nums.length / 2; i > 0; i--)
               adjustDown(nums, i, nums.length);
       }
   
       static void adjustDown(int[] nums, int k, int len) {
           nums[0] = nums[k];
           for (int i = k * 2; i < len; i *= 2) {
               if (i < len - 1 && nums[i] < nums[i + 1]) i++;
               if (nums[i] <= nums[0]) break;//每次比较的时候，都是与哨兵比较
               else {
                   nums[k] = nums[i];
                   k = i;
               }
           }
           nums[k] = nums[0];
       }
   
       static void swap(int[] nums, int i, int j) {
           int t = nums[i];
           nums[i] = nums[j];
           nums[j] = t;
       }
   }
   
   ```

   

5. [最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

   * 手写最小堆 AC

   ```Java
   class Solution {
       public int[] getLeastNumbers(int[] arr, int k) {
       if(arr.length == 0) return new int[0];
           int[] res = new int[k];
           int index = 0;
           buildMinHeap(arr);
           for (int i = arr.length - 1; i > arr.length - 1 - k; i--) {
               res[index++] = arr[0];
               swap(arr, i, 0);
               adjustDown(arr, 0, i);
           }
           return res;
       }
       void buildMinHeap(int[] nums) {
           for (int i = nums.length / 2; i >= 0; i--)
               adjustDown(nums, i, nums.length);
       }
   
       void adjustDown(int[] nums, int k, int len) {
           int t = nums[k];
           for (int i = k * 2; i < len; i *= 2) {
               if (i < len - 1 && nums[i] > nums[i + 1]) i++;
               if (nums[i] >= t) break;
               else {
                   nums[k] = nums[i];
                   k = i;
               }
           }
           nums[k] = t;
       }
   
       void swap(int[] nums, int i, int j) {
           int t = nums[i];
           nums[i] = nums[j];
           nums[j] = t;
       }
   }
   ```

   


## 4月25日

1. [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

   * 想到了之前在牛客写的一道题，用字典序求字符串的全排列。里面有这个算法，复习了一下

   ```Java
   class Solution {
       public void nextPermutation(int[] array) { 
       //  生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。
       //  这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。
   
       //从右向左找到第一个 比右边的数小的 记该数字为nums[i]
       //从右向左找到第一个 该数字比 array[i] 大的数字
       //交换这两个数字，然后将i右边的reverse得到下一个排列
   
           int i = array.length - 2;
           for (; i >= 0 && array[i] >= array[i + 1]; i--) ; //从右向左找到第一个 比右边的数小的
           if (i == -1) {//如果找不到比右边的数字小的，则该数组是递减的，直接返回数组的reverse
               reverse(array,0,array.length-1);
               return;
           } 
           int j = array.length - 1; 
           for (; j >= 0 && array[j] <= array[i]; j--) ; //从右向左找到第一个 该数字比 array[i] 大的数字
           swap(array,i,j);
           reverse(array, i + 1, array.length - 1);//交换i j,并将i右边的数组reverse
       }
   
       void reverse(int[] nums, int L, int R) {
           while(L < R) {
               int t = nums[L];
               nums[L] = nums[R];
               nums[R] = t;
               L++;R--;
           }
       }
   
       void swap(int[] nums, int i, int j){
           int t = nums[i];
           nums[i] = nums[j];
           nums[j] = t;
       }
   }
   ```

   

2. [字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

* 顺带用上一题的方法写了这一题，速度比暴力dfs快很多。

```Java
class Solution {
    public String[] permutation(String s) {
        if(s.length() == 0) return new String[0];
        if(s.length() == 1) return new String[]{s};
        List<String> res = new ArrayList<>();
        char[] c = s.toCharArray();
        Arrays.sort(c);
        res.add(new String(c));
        while(true) {
            String next = nextString(c);
            if(next.equals("finish"))
                break;
            else
                res.add(new String(c));
        }
        return res.toArray(new String[0]);
    }
    String nextString(char[] c) {
        int j = c.length - 2;
        for(; j >= 0 && c[j] >= c[j+1]; j--) ; //找到第一个 比右边的小的
        if(j == -1) return "finish";
        int i = c.length - 1;
        for(;i >= 0 && c[i] <= c[j]; i--) ;
        swap(c,i,j);
        reverse(c,j+1,c.length-1);
        return new String(c);
    }
    void swap(char[] c, int i, int j) {
        char t = c[i];
        c[i] = c[j];
        c[j] = t;
    }
    void reverse(char[] c, int L, int R) {
        while(L < R) {
            swap(c,L,R);
            L++; R--;
        }
    }
}
```

3. [全排列](https://leetcode-cn.com/problems/permutations/)

   [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

* 用字典序求全排列的算法解（有重复数字并不影响）

```Java
	class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length == 0) return res;
        if(nums.length == 1){
            res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));
            return res; 
        }
        Arrays.sort(nums);
        res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));
        while(true) {
            boolean flag = next(nums);
            if(flag)
                res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));
            else
                return res;
        }
    }
    boolean next(int[] nums) {
        int j = nums.length - 2;
        for(; j >= 0 && nums[j] >= nums[j+1]; j--) ; //找到第一个 比右边的小的
        if(j == -1) return false;
        int i = nums.length - 1;
        for(;i >= 0 && nums[i] <= nums[j]; i--) ;
        swap(nums,i,j);
        reverse(nums,j+1,nums.length-1);
        return true;
    }
    void swap(int[] c, int i, int j) {
        int t = c[i];
        c[i] = c[j];
        c[j] = t;
    }
    void reverse(int[] c, int L, int R) {
        while(L < R) {
            swap(c,L,R);
            L++; R--;
        }
    }
}
```

## 4月26日

1. [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

* 每日一题，复习一下

```Java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        return merge(lists,0,lists.length -1 );
    }
    public ListNode merge(ListNode[] lists, int L, int R) {
        if(L >= R) return lists[L];
        int mid = L + ((R - L) >> 1);
        ListNode left = merge(lists,L,mid);
        ListNode right = merge(lists, mid + 1, R);
        return mergeTwoLists(left,right);
    }
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if(l1 == null && l2 == null) return null;
            if(l1 == null) return l2;
            if(l2 == null) return l1;
            ListNode newHead = new ListNode(-1);
            ListNode p = newHead;
            while(l1 != null && l2 != null){
                if(l1.val < l2.val) {
                    p.next = l1;
                    p = p.next;
                    l1 = l1.next;
                } else {
                    p.next = l2;
                    p = p.next;
                    l2 = l2.next;
                }
            }
            while(l1 != null) {
                p.next = l1;
                p = p.next;
                l1 = l1.next;
            }
            while(l2 != null) {
                p.next = l2;
                p = p.next;
                l2 = l2.next;
            }
            p.next = null;
            return newHead.next;
        }
}
```

