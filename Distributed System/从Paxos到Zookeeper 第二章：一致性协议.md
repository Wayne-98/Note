---
title: 从Paxos到Zookeeper 第二章：一致性协议
date: {date}
tags: Distributed System
categories: 从Paxos到Zookeeper
---
在分布式系统中，每一个机器节点能够明确知道自己在进行事务操作中的结果的成败，但是无法直接获取到其他分布式节点的操作结果。因此，但一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 的特性，就需要引入一个称为“协调者”（Coordinator）的组件来统一调度所有分布式节点的执行逻辑，这些被调度的节点被称为“参与者”（Participant）。协调者负责调度参与者的行为，并最终决定参与者是否要把事务真正进行提交。基于这个思想，衍生了二阶段提交和三阶段提交两种协议。

## 2PC(Two-Phase Commit)

**阶段一：提交事务请求** （投票阶段：即各参与者投票表明是否要继续执行接下来的事务提交操作）

1. 事务询问

   协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。

2. 执行事务

   各参与者节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。

3. 各参与者向协调者反馈事务询问的响应

   如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行



**阶段二：执行事务提交**

1. 执行事务提交：所有的参与者反馈的都是 Yes 响应
   * 发送提交请求： 协调者向所有参与者发送 Commit 请求。
   * 事务提交：参与者收到 Commit 请求后，会正式的执行事务提交操作，并在完成提交之后释放在整个事务期间占用的事务资源。
   * 反馈事务提交结果：参与者在事务提交之后，向协调者发送 ACK 消息。
   * 完成事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务。

2. 中断事务：如果任何一个参与者向协调者发送了 No 响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。
   * 发送回滚请求：协调者向所有参与者发送 Rollback 请求。
   * 事务回滚：参与者在收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚后释放在整个事务期间占用的事务资源。
   * 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 ACK 消息。
   * 中断事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务中断

***

* **优点**：原理简单，实现方便
* **缺点**：同步阻塞，单点问题，脑裂，太过保守
  * 同步阻塞：2PC 的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态。也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。
  * 单点问题：如果协调者崩了，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。
  * 数据不一致：2PC 的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送 Commit 请求后，由于种种原因（局部网络异常，协调者尚未发送完所有 Commit 自身发生崩溃）导致最终只有部分参与者收到了 Commit 请求。那么收到 Commit 请求的参与者就会进行事务的提交，而其他没有收到 Commit 的参与者则无法进行事务提交。于是整个分布式系统出现了数据不一致的现象。
  * 太过保守：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠自身的超时机制来判断是否需要中断事务，这样的策略太过保守。 也就是 2PC 协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。

***

## 3PC(Three-Phase Commit)

是 2PC 的改进版，将二阶段提交协议的“提交事务请求”过程一分为二，形成了由 CanCommit、PreCommit 和 do Commit 三个阶段组成的事务处理协议。



**阶段一：CanCommit**

1. 事务询问：协调者向所有参与者发送一个包含事务内容的 CanCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。

2. 各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的 CanCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么就会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应。

**阶段二：PreCommit**

在阶段二中，协调者会根据参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，正常情况下，包含两种情况

* 执行事务预提交

  假如协调者从所有的参与者获得的反馈都是 Yes ，那么就会执行事务的预提交

  1. 发送预提交请求：协调者向所有参与者节点发出 PreCommit 的请求，并进入 Prepared 阶段。
  2. 事务预提交：参与者收到  PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。
  3. 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就反馈给协调者 Ack 响应，同时等待最终的指令：提交(commit) 或者 终止(abort).

* 中断事务

  假如任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。

  1. 发送中断请求：协调者向所有参与者节点发送 abort 请求。
  2. 中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求的过程中出现超时，参与者都会中断事务。

**阶段三： doCommit**

该阶段会执行真正的事务提交，会存在以下两种情况

* 执行提交
  1. 发送提交请求：假设协调者处于正常工作状态，并且收到了来自所有参与者的 Ack 响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发出 doCommit 请求。
  2. 事务提交：参与者收到 doCommit 请求后，会正式的执行事务提交操作，并在完成提交之后释放在整个事务期间占用的事务资源。
  3. 反馈事务提交结果：参与者在事务提交之后，向协调者发送 ACK 消息。
  4. 完成事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务。

* 中断事务

  进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。

  1. 发送中断请求：协调者向所有参与者节点发送 abort 请求。
  2. 事务回滚：参与者在收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚后释放在整个事务期间占用的事务资源。
  3. 反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 ACK 消息。
  4. 中断事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务中断。

***

一旦进入阶段三，可能会出现以下两种故障：

* 协调者出现问题
* 协调者和参与者之间的网络出现故障

无论出现哪种情况，最终都会导致参与者无法收到来自协调者的 doCommit 或是 abort 请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。

***

* **优点：**相对于 2PC ，3PC 最大的优点是减低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。
* **缺点：**参与者在收到 PreCommit 消息后，如果出现了网络分区，此时协调者所在的节点无法与参与者进行网络通信，这种情况下，参与者依然会进行事务的提交，这样会出现数据的不一致。

***

## Paxos

[微信PaxosStore：深入浅出Paxos算法协议](https://mp.weixin.qq.com/s/aJoXSQo9-zmukN2RsiZ3_g)

[微信自研生产级paxos类库PhxPaxos实现原理介绍](https://mp.weixin.qq.com/s/6VWUA5EDV2UIq4NqmQYWUA)



 **Proposer 生成提案**

1. Proposer 选择一个新的提案编号 Mn，然后向某个  Acceptor 集合的成员发送请求，要求该集合中 Acceptor 作出如下回应：

   * 向 Proposer 承诺，保证不再批准任何编号小于 Mn 的提案
   * 如果 Acceptor 已经批准过任何提案，那么其就向 Proposer 反馈当前该 Acceptor 已经批准的编号小于 Mn 但为最大编号的那个提案的值。

   

   我们将请求编号为 Mn 的提案的 Prepare 请求。

   

2. 如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果，那么它就可以产生编号为 Mn，value 的值为 Vn 的提案，这里的 Vn 是所有响应中编号最大的提案的 Value 值。（半数以上的 Acceptor 都没有批准过任何提案，即响应中不包含任何的提案，那么 Vn 的值可以由 Proposer 任意选择）。



在确定提案以后，Proposer 就会将该提案再次发给某个 Acceptor 集合，并期望获得他们的批准，称为 Accept 请求。



**Acceptor 批准提案**

* Prepare 请求：Acceptor 可以在任何时候响应一个 Prepare 请求。
* Accept 请求：在不违背 Acceptor 现有承诺的前提下，可以任意响应 Accept 请求。



一个 Acceptor 只要尚未响应过任何编号大于 Mn 的 Prepare 请求，那么它就可以接受这个编号为 Mn 的提案。