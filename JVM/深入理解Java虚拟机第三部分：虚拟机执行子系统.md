---
title: 深入理解Java虚拟机第三部分：虚拟机执行子系统
date: {date}
tags: Java
categories: JVM
---
# 类文件结构

## 无关系的基石

实现语言无关性的基石是**虚拟机**和**字节码存储格式**。 Java 虚拟机不与任何包括 Java 在内的语言绑定，它只与“ Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。

## Class类文件的结构

Class文件是一组以8字节为基础单位的**二进制流**。// 包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。

Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：

* 无符号数：基本的数据类型，1,2,4,8个字节，可以用来描述数字、索引引用、数量值或者UTF-8编码构成字符串值。
* 表：表是由多个无符号数或者其他表作为数据项构成的复合结构，习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。

### 魔数和Class文件的版本

Class 文件的头四个字节称为 Magic Number，它的唯一的作用就是确定这个文件是否是一个能被虚拟机接收的Class 文件(类似于文件后缀的作用)。0xCAFEBABY

紧接着魔数的4个字节存储的是 Class 文件的版本号，前两个字节是次版本，后两个是主版本。

### 常量池

主次版本号之后的是常量池入口，可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，也是 Class 文件中第一个出现的表类型数据项目。

常量池主要存放两大类常量：**字面量** (Literal) 和**符号引用** (Symbolic References)

* 字面量接近于Java语言层面的常量概念，如文本字符串、声明为 final 的常量值。

* 符号引用则属于编译原理方面的概念：

  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符

  

常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。

常量池中每一项常量都是一个表，截止 JDK13 常量表中分别有17种不同类型的常量，他们的表结构起始的第一位是个 u1 类型的标志位，代表着当前常量属于哪种常量类型。

例如  u1 类型的标志位中为7，可知这个常量属于 CONSTANT_Class_info 类型，此类型的常量代表一个类或者接口的符号引用。他的结构为一个 u1 类型的 tag 和一个 u2 类型的 name_index。tag是标志位，它用于区分常量类型；name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表了这个类（或者接口）的全限定名。

### 访问标志

在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等

### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个u2类型的数据，接口索引集合是一组u2类型的数据，Class文件中由这三项数据来确定该类型的继承关系。

u2类型的数据指向一个CONSTANT_Class_info的类描述符常量，通过常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。

### 字段表集合

字段表（field_info）用于描述接口或者类中声明的变量，包括类级变量以及实例变量，但是不包括方法内部声明的局部变量。

字段表结构：依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。

字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。

而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

* 全限定名，“org/fenixsoft/clazz/TestClass”
* 简单名称(name_index)则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。
* 方法和字段的描述符：作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值

字段表所包含的固定数据项目到 descriptor_index 为止就全部结束了，不过在 descriptor_index 之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。(ConstantValue)

### 方法表集合

结构和字段表几乎完全一致。

方法里的 Java 代码，经过 Javac 编译器编译成字节码指令之后，存放在方法属性表集合中一个名为 “Code” 的属性里面。

父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。

### 属性表集合

## 字节码指令简介

# 虚拟机类加载机制

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

## 类加载的时机

* 类从被加载到虚拟机内存直到卸载出内存的**生命周期**

1. 加载
2. 连接
   1. 验证
   2. 准备
   3. 解析：解析阶段不一定会按照顺序，为了支持 Java 语言的运行时绑定
3. 使用
4. 卸载

* 有且只有六种情况必须立即对类进行“初始化”

1. 遇到new、getstatic、putstatic或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
   1. 使用 new 关键字实例化对象的时候。
   2. 读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
   3. 调用一个类型的静态方法的时候。

2. 使用 java.lang.reflect 包的方法进行反射调用时，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
5. 当使用JDK 7新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK 8新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

## 类加载的过程

### 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

### 验证

目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。文件格式验证之后，字节流会进入内存的方法区中，所有之后的验证都是基于方法区的存储结构进行的。

1. **文件格式验证**
   * 是否以魔数 0xCAFEBABE 开头。
   * 主、次版本号是否在当前 Java 虚拟机接受范围之内。
   * 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。
   * 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
   * CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据。
   * Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

2. **元数据验证：对字节码描述的信息进行语义分析，保证符合 Java 语义规范**
   * 这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。
   * 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。
   * 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
   * 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。

3. **字节码验证：目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的**
   * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按 long 类型来加载入本地变量表中”这样的情况。
   * 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
   * 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

4. **符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段-解析阶段发生，可以看做是对类自身以外的信息(常量池中的各种符号引用)进行匹配校验**
   * 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   * 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
   * 符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当
     前类访问。

### 准备

**准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段**。从概念上讲，这些变量所使用的内存都应当在**方法区**中进行分配，但必须注意到方法区本身是一个**逻辑**上的区域。在JDK 7及之前，HotSpot 使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着 Class 对象一起存放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

* 这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。初始值“通常情况”下是数据类型的零值，如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。final

### 解析

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。

* 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。
* 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。

虚拟机可以根据需要选择在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

### 初始化

初始化阶段就是执行类构造器clinit()方法的过程。clinit()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。

clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。

## 类加载器

类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”，是在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

### 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

### 双亲委派模型

* 从 Java 虚拟机角度，只存在两种不同的类加载器：
  1. 启动类加载器，由C++语言实现，是虚拟机自身的一部分
  2. 其他所有的类加载器，由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader

* Java开发人员的角度：
  1. 启动类加载器：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且被虚拟机识别的类库加载到虚拟机内存中。
  2. 扩展类加载器：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有的类，开发者可以直接使用扩展类加载器。
  3. 应用程序类加载器（系统类加载器）：负责加载用户类路径上所指定的类库，开发者可以直接使用应用程序类加载器。应用程序中如果没有自定义过自己的类加载器，一般情况下这个就是程序中的默认类加载器。

不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。

**双亲委派模型的工作过程**：

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

**双亲委派模型的优点**：

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。

***

# 虚拟机字节码执行引擎

## 概述

不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择或者两者兼备，但是从外观上看所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 运行时栈帧结构

Java 虚拟机以方法作为最基本的执行单元，栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。

* 每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。

* 栈帧中需要多大的局部变量表，多深的操作数栈在编译程序代码之后就已经完全确定了，并且写入方法表的Code属性之中。

* 对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。 

### 局部变量表

局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽(VariableSlot, Slot)为最小单位，虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的 Slot 数量。(在 Java 程序被编译为 Class 文件时，就在方法的 Code 属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量)

### 操作数栈

做算术运算是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

Class 文件的常量池中存有大量的符号引用，**字节码中的方法调用指令**就以常量池里指向方法的**符号引用**作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。
另外一部分将在每一次运行期间都转化为直接引用，这部分就称为**动态连接**。

### 方法返回地址

正常完成出口：一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。

异常完成出口：方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：

1. 恢复上层方法的局部变量表和操作数栈

2. 把返回值压入调用者栈帧的操作数栈中
3. 调整PC计数器的值以指向方法调用指令后面的一条指令

## 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是**确定被调用的版本**，暂时还不涉及方法内部的具体运行过程。

Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址(直接引用),这个特性给 Java 带来了更强大的动态扩展能力。

### 解析

所有方法调用的目标方法在 Class 文件里面都是一个常量池中的**符号引用**，在类加载的**解析**阶段，会将其中的一**部分符号引用转化为直接引用**。



这种解析能够成立的前提是：该方法“**编译期可知，运行期不可变**”，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。



在Java虚拟机支持以下5条方法调用字节码指令，分别是：

1. invokestatic。用于调用静态方法。
2. invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。
3. invokevirtual。用于调用所有的虚方法。
4. invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。
5. invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。

只要能被**invokestatic**和**invokespecial**指令调用的方法，都可以在**解析阶段中确定唯一的调用版本**，Java语言里符合这个条件的方法共有**静态方法**、**私有方法**、**实例构造器**、**父类**方法4种，再加上被**final**修饰的方法（尽管它使用invokevirtual指令调用），**这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用**。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。

### 分派

* **静态分派**

```Java
package org.fenixsoft.polymorphic;
/**
* 方法静态分派演示
* @author zzm
*/
public class StaticDispatch {
	static abstract class Human {
	}
	static class Man extends Human {
	}
	static class Woman extends Human {
	}
	public void sayHello(Human guy) {
		System.out.println("hello,guy!");
	}
	public void sayHello(Man guy) {
		System.out.println("hello,gentleman!");
	}
	public void sayHello(Woman guy) {
		System.out.println("hello,lady!");
	}
	public static void main(String[] args) {
		Human man = new Man();
		Human woman = new Woman();
		StaticDispatch sr = new StaticDispatch();
		sr.sayHello(man);	//hello,guy!
		sr.sayHello(woman);	//hello,guy!
	}
}
```

静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，**变量本身的静态类型不会被改变**，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

```java
// 实际类型变化
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
// 静态类型变化
sr.sayHello((Man) human)
sr.sayHello((Woman) human)
//human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。
```

编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段，Javac 编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到 main() 方法里的两条 invokevirtual 指令的参数中。

所有**依赖静态类型来决定方法执行版本的分派动作，都称为静态分派**。静态分派的最典型应用表现就是**方法重载**。静态分派发生在编译阶段。

* **动态分派**

```Java
/**
* 方法动态分派演示
* @author zzm
*/
public class DynamicDispatch {
	static abstract class Human {
		protected abstract void sayHello();
	}
	static class Man extends Human {
		@Override
		protected void sayHello() {
			System.out.println("man say hello");
		}
	}
	static class Woman extends Human {
		@Override
		protected void sayHello() {
			System.out.println("woman say hello");
		}
	}
	public static void main(String[] args) {
		Human man = new Man();
		Human woman = new Woman();
		man.sayHello();//man say hello
		woman.sayHello();//woman say hello
		man = new Woman();
		man.sayHello();//woman say hello
	}
}
```

invokevirtual 指令的运行时解析过程：

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回 java.lang.IllegalAccessError 异常。
3. 否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。

正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会**根据方法接收者的实际类型来选择方法版本**，这个过程就是Java语言中方法**重写**的本质。我们把这种在**运行期根据实际类型确定方法执行版本的分派过程称为动态分派**。

### 虚拟机动态分派的实现

动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址。

## 基于栈的字节码解释执行引擎

### 解释执行

Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。

### 基于栈的指令集与基于寄存器的指令集

基于栈的指令集主要优点是可移植，程序不直接依赖这些硬件寄存器，避免受到硬件的约束。

栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，不过这里的执行速度是要局限在解释执行的状态下，如果经过即时编译器输出成物理机上的汇编指令流，那就与虚拟机采用哪种指令集架构没有什么关系了。

在解释执行时，**栈架构**指令集的代码虽然紧凑，但是完成相同功能所需的**指令数量**一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。**更重要的是栈实现在内存中**，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取**栈顶缓存**的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于**指令数量和内存访问的原因**，导致了栈架构指令集的执行速度会相对慢上一点。

