## 5月2号

1. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || in.length == 0 || pre.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                root.right = buildTree(Arrays.copyOfRange(pre,i+1,pre.length), Arrays.copyOfRange(in, i+1, in.length));
            }
        }
        return root;
    }
}
```

* 解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来

2. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        // if() return false;
        ListNode mid = findMid(head);
        ListNode reverse = reverseList(mid);
        while(head != mid) {
            if(head.val != reverse.val) return false;
            head = head.next;
            reverse = reverse.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head) {
        ListNode newHead = new ListNode(-1);
        ListNode t = null;
        while(head != null) {
            t = head.next;
            head.next = newHead.next;
            newHead.next = head;
            head = t;
        }
        return newHead.next;
    }
    ListNode findMid(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

## 5月3号

1. [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```Java

class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || pre.length == 0 || in.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                root.right = buildTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return root;
    }
}
```

2. [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```Java
class Solution {
    boolean[][] v;
    char[] c;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board[0].length == 0) return false;
        v = new boolean[board.length][board[0].length];
        c = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, i, j, 0)) return true;
            }
        }
        return false;
    }

    boolean dfs(char[][] board, int row, int col, int len) {
        if(v[row][col] || board[row][col] != c[len]) return false;
        if(len == c.length - 1) return true; 
        v[row][col] = true;
        if(row > 0 && dfs(board, row - 1, col, len + 1)) return true;
        if(row < board.length - 1 && dfs(board, row + 1, col, len + 1)) return true;
        if(col > 0 && dfs(board, row, col - 1, len + 1)) return true;
        if(col < board[0].length - 1 && dfs(board, row, col + 1, len + 1)) return true;
        v[row][col] = false;
        return false;
    }
}	
```

3. [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```Java
class Solution {
    boolean[][] v;
    int threshold;
    public int movingCount(int m, int n, int k) {
        v = new boolean[m][n];
        threshold = k;
        return dfs(m,n,0,0);
    }
    int dfs(int rows, int cols, int row, int col) {
        int count = 0;
        if(row < rows && col <cols && sum(row) + sum(col) <= threshold && !v[row][col]){
            v[row][col] = true;
            count = 1 + dfs(rows, cols, row + 1, col) + dfs(rows, cols, row, col + 1);
        }
        return count;
    }
    int sum(int n) {
        int sum = 0;
        while(n > 0){
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
}
```

* 还需要再复习一下

## 5月4号

1. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```Java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() < 1) return "";
        int left = 0, right = 0;
        for(int i = 0; i < s.length() - 1; i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if(len > (right - left + 1)) {
                left = i - (len - 1) / 2;// 注意此处是 len - 1
                right = i + len / 2;
            }
        }
        return s.substring(left, right + 1);
    }

    private int expand(String s, int i, int j) {
        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {
            i--; j++;
        }
        return j - i - 1;
    }
}
```

2. [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```java
class Solution {
    public int myAtoi(String str) {
        if(str.length() == 0) return 0;
        int index = 0, res = 0;
        while(index < str.length() && str.charAt(index) == ' ') index++;
        if(index == str.length()) return 0;
        boolean positive = true;
        char fristChar = str.charAt(index);
        if(!isNum(fristChar)) {
            if(fristChar != '+' && fristChar != '-') return 0;
            positive = (fristChar != '-');
            index++;
        }
        int limit = positive ? -Integer.MAX_VALUE : Integer.MIN_VALUE;
        while(index < str.length() && isNum(str.charAt(index))) {
            int t = str.charAt(index++) - '0';
            // 如果 res * 10 - t 越界, 那么 res * 10 - t < limit
            if(res < (limit + t) / 10) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 - t;
        }

        return positive ? -res : res;
    }
    private boolean isNum(char c) {
        int t = c - '0';
        if(t >= 0 && t <= 9) return true;
        return false;
    }
}
```

## 5月5号

1. [组合总和](https://leetcode-cn.com/problems/combination-sum/)

* 典型的回溯法解题，需要考虑去重
* 回溯法的应用：当需要对所有的结果进行暴力搜索，也就是对决策树进行遍历，适当的时候进行剪枝

```Pytho
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates.length == 0) return res;
        List<Integer> list = new ArrayList<>();
        backtrack(list, candidates, target, 0);
        return res;
    }
    // 剪枝方法：使用了一个 index 记录当前的访问位置，每次回溯的时候保证不会往后走，只会往前走。
    void backtrack(List<Integer> list, int[] candidates, int target, int index) {
        if(target == 0) {
            res.add(new ArrayList(list));
            return;
        }
        if(target > 0) {
            for(int i = index; i < candidates.length; i++) {
                list.add(candidates[i]);
                
                // 因为组合中可以由重复的数字出现：223 7， 所以每次回溯的时候继续从当前位置走
                backtrack(list, candidates, target - candidates[i], i);
                list.remove(list.size() - 1);
            }
        }
    }

// 剪枝方法：维护一个非递减的列表，所以既满足了组合中可以出现重复数字，并且不会出现每次组合重复的情况
// 例如 223 232 322 都可以是 7 的组合，但是限制了非递减 所以结果只有 322
    
    // void backtrack(List<Integer> list, int[] candidates, int target ) {
    //     if(target == 0) {
    //         res.add(new ArrayList(list));
    //         return;
    //     }
    //     if(target > 0) {
    //         for(int i = 0; i < candidates.length; i++) {
    //             if(!list.isEmpty() && candidates[i] > list.get(list.size() - 1)) continue;
    //             list.add(candidates[i]);
    //             dfs(list, candidates, target - candidates[i]);
    //             list.remove(list.size() - 1);
    //         }
    //     }
    // }
}
```

2. [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```Java
// // 例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下： 
// // 自右至左找出排列中第一个比右边数字小的数字4     839647521
// // 在该数字后自右向左找到第一个比4大的数字5       839647521
// // 将5与4交换                                839657421
// // 将7421倒转                                839651247
// // 所以839647521的下一个排列是                 839651247。

class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length < 2) return;
        int j = nums.length - 2;
        while(j >= 0 && nums[j] >= nums[j + 1]) j--;
        if(j == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int i = nums.length - 1;
        while(i > j && nums[i] <= nums[j]) i--;
        swap(nums, i, j);
        reverse(nums, j + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int L, int R) {
        while(L < R) {
            swap(nums, L++, R--);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

3. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root, pre = null;
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            // 中序遍历是一个单调递增的序列
            if(pre != null && pre.val >= cur.val) return false;
            pre = cur;
            cur = cur.right;
        }
        return true;
    }
    
    // 每次记录 up down 即父节点和子节点
    // public boolean isValidBST(TreeNode root) {
    //     if(root == null) return true;
    //     return help(root, Long.MAX_VALUE,Long.MIN_VALUE);
    // }

    // private boolean help(TreeNode root, long up, long down) {
    //     if(root != null) {
    //         if(root.val >= up) return false;
    //         if(root.val <= down) return false;
    //         return help(root.left, root.val, down) && help(root.right, up, root.val);
    //     }
    //     return true;
    // }
}
```

4. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        // 初始化的时候不能为null 否则之后的判断不合理
        // 但是让pre = root 也不合理，因为此时上次访问的节点不是root !!!待解决
        TreeNode pre = root; 
        s.push(root);
        while(s.size() > 0) {
            TreeNode t = s.peek();
            // 当pre为空的时候，有一个节点其右节点为空，那么此时 pre == t.right
            if(t.left != null && pre != t.left && pre != t.right) { 
                s.push(t.left);
            } else if(t.right != null && pre != t.right) { 
                s.push(t.right);
            } else {
                TreeNode cur = s.pop();
                pre = cur;
                res.add(cur.val);
            }
        }
        return res;
    }
}
```

5. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root; 
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                res.add(cur.val);
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            cur = cur.right;
        }
        return res;
    }

    // public List<Integer> preorderTraversal(TreeNode root) {
    //     List<Integer> res = new ArrayList<>();
    //     if(root == null) return res;
    //     Stack<TreeNode> s = new Stack<>();
    //     s.push(root);
    //     while(s.size() > 0) {
    //         TreeNode cur = s.pop();
    //         res.add(cur.val);
    //         if(cur.right != null) s.push(cur.right);
    //         if(cur.left != null) s.push(cur.left);
    //     }
    //     return res;
    // }
}
```

## 5月6号

1. [N皇后](https://leetcode-cn.com/problems/n-queens/)

```Java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        if(n == 0) return res;
        char[][] board = new char[n][n];
        for(char[] ch : board) Arrays.fill(ch, '.');
        backtrack(board, 0);
        return res;
    }

    void backtrack(char[][] board, int row) {
        if(row == board.length) {
            res.add(charsToString(board));
            return;
        }
        for(int col = 0; col < board[0].length; col++) {
            if(isValid(board, row, col)) {
                board[row][col] = 'Q';
                backtrack(board, row + 1);
                board[row][col] = '.';
            }
        }
    }

    private boolean isValid(char[][] board, int row, int col) {
        for(char[] c : board)
            if(c[col] == 'Q')
                return false;
        for(int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--)
            if(board[i][j] == 'Q')
                return false;
        for(int i = row - 1, j = col + 1; i >= 0 && j < board[i].length; i--, j++)
            if(board[i][j] == 'Q')
                return false;
        return true;
    }

    private List<String> charsToString(char[][] c){
        List<String> l = new ArrayList<>();
        for(char[] ch : c) {
            l.add(String.valueOf(ch));
        }
        return l;
    }
}
```

2. [全排列](https://leetcode-cn.com/problems/permutations/)

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] v;
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length < 1) return res;
        v = new boolean[nums.length];
        backtrack(nums);
        return res;
    }
    void backtrack(int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < nums.length; i++) {
            if(!v[i]) {
                v[i] = true;
                path.add(nums[i]);
                backtrack(nums);
                path.remove(path.size() - 1);
                v[i] = false;
            }
        }
    }
}
```

3. [LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

```Java
class LRUCache {
    Map<Integer, Node> m;
    DoubleList cache;
    int capacity;
    public LRUCache(int capacity) {
        m = new HashMap<>();
        cache = new DoubleList();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if(m.containsKey(key)) {
            int val = m.get(key).value;
            put(key,val);
            return val;
        } else {
            return -1;
        }
    }
    
    public void put(int key, int value) {
        Node node = new Node(key, value);
        if(m.containsKey(key)) {
            cache.remove(m.get(key));
            cache.addFirst(node);
            m.put(key, node);
        } else {
            if(cache.size == capacity) {
                Node last = cache.removeLast();
                m.remove(last.key);
            }
            cache.addFirst(node);
            m.put(key, node);
        }

    }

    private class DoubleList{
        Node head;
        Node tail;
        int size;
        public DoubleList() {
            this.head = new Node(-1, -1);
            this.tail = new Node(-1, -1);
            head.next = tail;
            tail.pre = head;
            this.size = 0;
        }

        public void addFirst(Node node) {
            size++;
            node.pre = head;
            node.next = head.next;
            head.next.pre = node;
            head.next = node;
        }

        public void remove(Node node) {
            size--;
            node.next.pre = node.pre;
            node.pre.next = node.next;
        }

        public Node removeLast() {
            if(tail.pre == head) return null;
            Node last = tail.pre;
            remove(last);
            return last;
        }
    }

    private class Node{
        int key;
        int value;
        Node pre;
        Node next;
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

4. [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```Java
class Solution {
    public void rotate(int[][] matrix) {
        int temp = -1;
        // 第一个 for 用来控制每次的方块大小，因为是 n * n 的，所以用两个变量就okk
        for(int start = 0, end = matrix[0].length - 1; start < end; start++, end--) {
            
            // 第二个 for 用来交换本次方块的值
            for(int s = start, e = end; s < end; s++, e--) {
                temp = matrix[start][s];
                matrix[start][s] = matrix[e][start];
                matrix[e][start] = matrix[end][e];
                matrix[end][e] = matrix[s][end];
                matrix[s][end] = temp;
            }
        }
    }
}

```

5. [不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```Java
class Solution {
    public int add(int a, int b) {
        while(b != 0) {
            int t = a ^ b;
            b = ((a & b) << 1);
            a = t;
        }
        return a;
    }
}

// 异或：相同则为0 不同则为1，相当于 两个数的不进位和
// & << 1：相当于两个数和的进位
```

## 5月7号

1. [从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder.length == 0 || postorder.length == 0) return null;
        TreeNode root = new TreeNode(postorder[postorder.length - 1]);
        for(int i = 0; i < inorder.length; i++) {
            if(inorder[i] == root.val) {
                root.left = buildTree(Arrays.copyOfRange(inorder, 0, i), Arrays.copyOfRange(postorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(inorder, i + 1, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length - 1));
            }
        }
        return root;
    //     return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    // private TreeNode build(int[] in, int inL, int inR, int[] post, int postL, int postR) {
    //     if(inL > inR || postL > postR) return null;
    //     TreeNode root = new TreeNode(post[postR]);
    //     int i = 0;
    //     while(in[inL + i] != root.val) i++;
    //     root.left = build(in, inL, inL + i - 1, post, postL, postL + i - 1);
    //     root.right = build(in, inL + i + 1, inR, post, postL + i, postR - 1);
    //     return root;
    // }

}
```

2. [将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums, 0, nums.length);
    }
    TreeNode toBST(int[] nums, int left, int right){
        if(left >= right) return null;
        int mid = left + ((right - left) >> 1);
        TreeNode root = new TreeNode(nums[mid]);
        root.left = toBST(nums, left, mid);
        root.right = toBST(nums, mid + 1, right);
        return root;
    }
}
```

