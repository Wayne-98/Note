# 1. 操作系统概述

* 操作系统的特征

1. **并发**：并发是指两个或多个事件在同一时间间隔内发生。
2. **共享**：即资源共享，是指系统中的资源可供内存中多个并发执行的程序共同使用。

3. 虚拟：是指把一个物理上的实体虚拟成多个逻辑上的对应物。
   * 虚拟技术：时分复用技术，空分复用技术

4. 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是操作系统的异步性。

* **内核**（核心态）

1. 时钟管理：提供系统时间、实现进程切换
2. 中断机制：提高 CPU 的利用率
3. 原语
4. 系统控制的数据结构及处理

* **中断**：当中断或者异常发生的时候， 运行用户态的 CPU 会立即进入核心态，通过硬件实现的
* **系统调用**：是用户在程序中调用操作系统提供的一些子功能。系统中的各种共享资源都是由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（存储分配、进行 I/O 传输、管理文件），都必须通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成。

# 2.1 进程管理

进程映像：程序段、相关数据段和 PCB (静态的)

进程：进程是进程映像的运行过程，是系统进行资源分配和调度的一个独立单位。（描述**动态**）

进程状态：创建 就绪 运行 阻塞(等待) 结束

进程之间的通信：

1. 共享存储

 	2. 消息传递
 	3. 管道通信

线程与进程的区别：调度、拥有资源、并发性、系统开销、地址空间和其他资源、通信方面

线程的实现方式：

 	1. 用户级线程：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模型中，用户级线程对操作系统不可见。
     * 优点：线程管理是在用户级空间进行的，因而效率比较高
     * 缺点：当一个线程在使用内核服务的时候被阻塞，那么整个进程就会被阻塞；多个线程不能并行的运行在多处理机上。
 	2. 内核级线程：将每个用户级线程映射到一个内核级线程
     * 优点：当一个线程被阻塞的时候，另一个线程继续执行，并发能力强
     * 缺点：每创建一个用户级线程都需要创建一个内核级线程与之对应，创建线程的开销比较大，会影响到用户程序的性能。

![](https://github.com/Wayne-98/image/blob/master/Operating%20System/Process.png?raw=true)

# 2.2 处理机调度

* 调度的层次（三级调度）

1. 作业调度：内存与辅存之间的调度，每个作业只调入和调出一次。
2. 中级调度(内存调度)：引入是为了提高内存的利用率和系统的吞吐量。将暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起态。
3. 进程调度：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。



* 调度的时机、切换与过程

不能进程进程调度与切换的几种情况：

1. 处理中断的过程中

 	2. 进程在操作系统内核临界区中
 	3. 其他需要完全屏蔽中断的原子操作过程中

应当进行进程调度与切换的情况有：

1. 发生引起调度条件，并且当前进程无法继续执行下去，可以马上进行调度与切换。(非剥夺调度)

 	2. 当中断处理结束或自陷处理结束后，返回被中断进程的用户态执行现场前。若置上请求调度标志，即可马上进行进程的调度与切换(剥夺式调度)



* 调度的基本准则

1. CPU 利用率 2. 系统吞吐量 3. 周转时间 4. 等待时间 5. 响应时间



* 典型的调度算法

1. 先来先服务 
2. 短作业优先 
3. 优先级调度 
4. 高响应比优先调度 （响应比 = （等待时间 + 要求服务时间） / 要求服务时间）
5. 时间片轮转调度
6. 多级反馈队列调度 

![](https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%B0%83%E5%BA%A6.png?raw=true)

## 2.3 进程同步

* 同步和互斥

1. 同步：直接制约关系，指为完成某个任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递消息所产生的制约关系。进程间的直接制约关系，源于它们之间的合作。

2. 互斥：简介制约关系，当一个进程进入临界区使用资源的时候，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。

* 生产者消费者、读者写者、哲学家进餐

![](https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.png?raw=true)

## 2.4 死锁

* 死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。
* 死锁产生的必要条件：
  1. 互斥
  2. 不可剥夺
  3. 请求和保持
  4. 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

* 死锁的处理策略：

  1. 预防死锁：破坏 4 个条件其中之一。

  2. 避免死锁：银行家
  3. 死锁的检测以及解除

* 死锁预防

  1. 破坏互斥：不可行
  2. 破坏不可剥夺：不可行
  3. 破坏请求和保持：一次分配所有资源，浪费资源，申请不到所有资源可能会出现“饥饿”现象
  4. 破坏循环等待：给资源编序号，按序申请。

* 死锁避免：

  1. 系统安全状态：系统能够按照某种进程推进顺序，为每个进程分配其所需资源，使每个进程多可以顺利的完成。
  2. 银行家算法：
     * 可用资源矢量
     * 最大需求矩阵
     * 分配矩阵
     * 需求矩阵

* 死锁的检测与解除

  1. 资源分配图

  ![](https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png?raw=true)

  2. 死锁定理：S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理
  3. 死锁解除：
     1. 资源剥夺法：挂起某些死锁进程，抢占它的资源
     2. 资源撤销法：按照进程的优先级和撤销进程的代价的高低，强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源
     3. 进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

  ![](https://github.com/Wayne-98/image/blob/master/Operating%20System/%E6%AD%BB%E9%94%81.png?raw=true)

