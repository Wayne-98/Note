## 5月2号

1. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || in.length == 0 || pre.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                root.right = buildTree(Arrays.copyOfRange(pre,i+1,pre.length), Arrays.copyOfRange(in, i+1, in.length));
            }
        }
        return root;
    }
}
```

* 解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来

2. [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        // if() return false;
        ListNode mid = findMid(head);
        ListNode reverse = reverseList(mid);
        while(head != mid) {
            if(head.val != reverse.val) return false;
            head = head.next;
            reverse = reverse.next;
        }
        return true;
    }
    ListNode reverseList(ListNode head) {
        ListNode newHead = new ListNode(-1);
        ListNode t = null;
        while(head != null) {
            t = head.next;
            head.next = newHead.next;
            newHead.next = head;
            head = t;
        }
        return newHead.next;
    }
    ListNode findMid(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

## 5月3号

1. [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```Java

class Solution {
    public TreeNode buildTree(int[] pre, int[] in) {
        if(pre == null || in == null || pre.length == 0 || in.length == 0) return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++) {
            if(in[i] == pre[0]) {
                root.left = buildTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                root.right = buildTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
            }
        }
        return root;
    }
}
```

2. [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```Java
class Solution {
    boolean[][] v;
    char[] c;
    public boolean exist(char[][] board, String word) {
        if(board.length == 0 || board[0].length == 0) return false;
        v = new boolean[board.length][board[0].length];
        c = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, i, j, 0)) return true;
            }
        }
        return false;
    }

    boolean dfs(char[][] board, int row, int col, int len) {
        if(v[row][col] || board[row][col] != c[len]) return false;
        if(len == c.length - 1) return true; 
        v[row][col] = true;
        if(row > 0 && dfs(board, row - 1, col, len + 1)) return true;
        if(row < board.length - 1 && dfs(board, row + 1, col, len + 1)) return true;
        if(col > 0 && dfs(board, row, col - 1, len + 1)) return true;
        if(col < board[0].length - 1 && dfs(board, row, col + 1, len + 1)) return true;
        v[row][col] = false;
        return false;
    }
}	
```

3. [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```Java
class Solution {
    boolean[][] v;
    int threshold;
    public int movingCount(int m, int n, int k) {
        v = new boolean[m][n];
        threshold = k;
        return dfs(m,n,0,0);
    }
    int dfs(int rows, int cols, int row, int col) {
        int count = 0;
        if(row < rows && col <cols && sum(row) + sum(col) <= threshold && !v[row][col]){
            v[row][col] = true;
            count = 1 + dfs(rows, cols, row + 1, col) + dfs(rows, cols, row, col + 1);
        }
        return count;
    }
    int sum(int n) {
        int sum = 0;
        while(n > 0){
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
}
```

* 还需要再复习一下

## 5月4号

1. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```Java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() < 1) return "";
        int left = 0, right = 0;
        for(int i = 0; i < s.length() - 1; i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if(len > (right - left + 1)) {
                left = i - (len - 1) / 2;// 注意此处是 len - 1
                right = i + len / 2;
            }
        }
        return s.substring(left, right + 1);
    }

    private int expand(String s, int i, int j) {
        while(i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {
            i--; j++;
        }
        return j - i - 1;
    }
}
```

2. [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```java
class Solution {
    public int myAtoi(String str) {
        if(str.length() == 0) return 0;
        int index = 0, res = 0;
        while(index < str.length() && str.charAt(index) == ' ') index++;
        if(index == str.length()) return 0;
        boolean positive = true;
        char fristChar = str.charAt(index);
        if(!isNum(fristChar)) {
            if(fristChar != '+' && fristChar != '-') return 0;
            positive = (fristChar != '-');
            index++;
        }
        int limit = positive ? -Integer.MAX_VALUE : Integer.MIN_VALUE;
        while(index < str.length() && isNum(str.charAt(index))) {
            int t = str.charAt(index++) - '0';
            // 如果 res * 10 - t 越界, 那么 res * 10 - t < limit
            if(res < (limit + t) / 10) return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 - t;
        }

        return positive ? -res : res;
    }
    private boolean isNum(char c) {
        int t = c - '0';
        if(t >= 0 && t <= 9) return true;
        return false;
    }
}
```

## 5月5号

1. [组合总和](https://leetcode-cn.com/problems/combination-sum/)

* 典型的回溯法解题，需要考虑去重
* 回溯法的应用：当需要对所有的结果进行暴力搜索，也就是对决策树进行遍历，适当的时候进行剪枝

```Pytho
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates.length == 0) return res;
        List<Integer> list = new ArrayList<>();
        backtrack(list, candidates, target, 0);
        return res;
    }
    // 剪枝方法：使用了一个 index 记录当前的访问位置，每次回溯的时候保证不会往后走，只会往前走。
    void backtrack(List<Integer> list, int[] candidates, int target, int index) {
        if(target == 0) {
            res.add(new ArrayList(list));
            return;
        }
        if(target > 0) {
            for(int i = index; i < candidates.length; i++) {
                list.add(candidates[i]);
                
                // 因为组合中可以由重复的数字出现：223 7， 所以每次回溯的时候继续从当前位置走
                backtrack(list, candidates, target - candidates[i], i);
                list.remove(list.size() - 1);
            }
        }
    }

// 剪枝方法：维护一个非递减的列表，所以既满足了组合中可以出现重复数字，并且不会出现每次组合重复的情况
// 例如 223 232 322 都可以是 7 的组合，但是限制了非递减 所以结果只有 322
    
    // void backtrack(List<Integer> list, int[] candidates, int target ) {
    //     if(target == 0) {
    //         res.add(new ArrayList(list));
    //         return;
    //     }
    //     if(target > 0) {
    //         for(int i = 0; i < candidates.length; i++) {
    //             if(!list.isEmpty() && candidates[i] > list.get(list.size() - 1)) continue;
    //             list.add(candidates[i]);
    //             dfs(list, candidates, target - candidates[i]);
    //             list.remove(list.size() - 1);
    //         }
    //     }
    // }
}
```

2. [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```Java
// // 例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下： 
// // 自右至左找出排列中第一个比右边数字小的数字4     839647521
// // 在该数字后自右向左找到第一个比4大的数字5       839647521
// // 将5与4交换                                839657421
// // 将7421倒转                                839651247
// // 所以839647521的下一个排列是                 839651247。

class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length < 2) return;
        int j = nums.length - 2;
        while(j >= 0 && nums[j] >= nums[j + 1]) j--;
        if(j == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int i = nums.length - 1;
        while(i > j && nums[i] <= nums[j]) i--;
        swap(nums, i, j);
        reverse(nums, j + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int L, int R) {
        while(L < R) {
            swap(nums, L++, R--);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

3. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root, pre = null;
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            // 中序遍历是一个单调递增的序列
            if(pre != null && pre.val >= cur.val) return false;
            pre = cur;
            cur = cur.right;
        }
        return true;
    }
    
    // 每次记录 up down 即父节点和子节点
    // public boolean isValidBST(TreeNode root) {
    //     if(root == null) return true;
    //     return help(root, Long.MAX_VALUE,Long.MIN_VALUE);
    // }

    // private boolean help(TreeNode root, long up, long down) {
    //     if(root != null) {
    //         if(root.val >= up) return false;
    //         if(root.val <= down) return false;
    //         return help(root.left, root.val, down) && help(root.right, up, root.val);
    //     }
    //     return true;
    // }
}
```

4. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        // 初始化的时候不能为null 否则之后的判断不合理
        // 但是让pre = root 也不合理，因为此时上次访问的节点不是root !!!待解决
        TreeNode pre = root; 
        s.push(root);
        while(s.size() > 0) {
            TreeNode t = s.peek();
            // 当pre为空的时候，有一个节点其右节点为空，那么此时 pre == t.right
            if(t.left != null && pre != t.left && pre != t.right) { 
                s.push(t.left);
            } else if(t.right != null && pre != t.right) { 
                s.push(t.right);
            } else {
                TreeNode cur = s.pop();
                pre = cur;
                res.add(cur.val);
            }
        }
        return res;
    }
}
```

5. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        TreeNode cur = root; 
        while(s.size() > 0 || cur != null) {
            while(cur != null) {
                res.add(cur.val);
                s.push(cur);
                cur = cur.left;
            }
            cur = s.pop();
            cur = cur.right;
        }
        return res;
    }

    // public List<Integer> preorderTraversal(TreeNode root) {
    //     List<Integer> res = new ArrayList<>();
    //     if(root == null) return res;
    //     Stack<TreeNode> s = new Stack<>();
    //     s.push(root);
    //     while(s.size() > 0) {
    //         TreeNode cur = s.pop();
    //         res.add(cur.val);
    //         if(cur.right != null) s.push(cur.right);
    //         if(cur.left != null) s.push(cur.left);
    //     }
    //     return res;
    // }
}
```

## 5月6号

1. [N皇后](https://leetcode-cn.com/problems/n-queens/)

```Java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        if(n == 0) return res;
        char[][] board = new char[n][n];
        for(char[] ch : board) Arrays.fill(ch, '.');
        backtrack(board, 0);
        return res;
    }

    void backtrack(char[][] board, int row) {
        if(row == board.length) {
            res.add(charsToString(board));
            return;
        }
        for(int col = 0; col < board[0].length; col++) {
            if(isValid(board, row, col)) {
                board[row][col] = 'Q';
                backtrack(board, row + 1);
                board[row][col] = '.';
            }
        }
    }

    private boolean isValid(char[][] board, int row, int col) {
        for(char[] c : board)
            if(c[col] == 'Q')
                return false;
        for(int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--)
            if(board[i][j] == 'Q')
                return false;
        for(int i = row - 1, j = col + 1; i >= 0 && j < board[i].length; i--, j++)
            if(board[i][j] == 'Q')
                return false;
        return true;
    }

    private List<String> charsToString(char[][] c){
        List<String> l = new ArrayList<>();
        for(char[] ch : c) {
            l.add(String.valueOf(ch));
        }
        return l;
    }
}
```

2. [全排列](https://leetcode-cn.com/problems/permutations/)

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] v;
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length < 1) return res;
        v = new boolean[nums.length];
        backtrack(nums);
        return res;
    }
    void backtrack(int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < nums.length; i++) {
            if(!v[i]) {
                v[i] = true;
                path.add(nums[i]);
                backtrack(nums);
                path.remove(path.size() - 1);
                v[i] = false;
            }
        }
    }
}
```

3. [LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

```Java
class LRUCache {
    Map<Integer, Node> m;
    DoubleList cache;
    int capacity;
    public LRUCache(int capacity) {
        m = new HashMap<>();
        cache = new DoubleList();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if(m.containsKey(key)) {
            int val = m.get(key).value;
            put(key,val);
            return val;
        } else {
            return -1;
        }
    }
    
    public void put(int key, int value) {
        Node node = new Node(key, value);
        if(m.containsKey(key)) {
            cache.remove(m.get(key));
            cache.addFirst(node);
            m.put(key, node);
        } else {
            if(cache.size == capacity) {
                Node last = cache.removeLast();
                m.remove(last.key);
            }
            cache.addFirst(node);
            m.put(key, node);
        }

    }

    private class DoubleList{
        Node head;
        Node tail;
        int size;
        public DoubleList() {
            this.head = new Node(-1, -1);
            this.tail = new Node(-1, -1);
            head.next = tail;
            tail.pre = head;
            this.size = 0;
        }

        public void addFirst(Node node) {
            size++;
            node.pre = head;
            node.next = head.next;
            head.next.pre = node;
            head.next = node;
        }

        public void remove(Node node) {
            size--;
            node.next.pre = node.pre;
            node.pre.next = node.next;
        }

        public Node removeLast() {
            if(tail.pre == head) return null;
            Node last = tail.pre;
            remove(last);
            return last;
        }
    }

    private class Node{
        int key;
        int value;
        Node pre;
        Node next;
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

4. [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```Java
class Solution {
    public void rotate(int[][] matrix) {
        int temp = -1;
        // 第一个 for 用来控制每次的方块大小，因为是 n * n 的，所以用两个变量就okk
        for(int start = 0, end = matrix[0].length - 1; start < end; start++, end--) {
            
            // 第二个 for 用来交换本次方块的值
            for(int s = start, e = end; s < end; s++, e--) {
                temp = matrix[start][s];
                matrix[start][s] = matrix[e][start];
                matrix[e][start] = matrix[end][e];
                matrix[end][e] = matrix[s][end];
                matrix[s][end] = temp;
            }
        }
    }
}

```

5. [不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```Java
class Solution {
    public int add(int a, int b) {
        while(b != 0) {
            int t = a ^ b;
            b = ((a & b) << 1);
            a = t;
        }
        return a;
    }
}

// 异或：相同则为0 不同则为1，相当于 两个数的不进位和
// & << 1：相当于两个数和的进位
```

## 5月7号

1. [从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder.length == 0 || postorder.length == 0) return null;
        TreeNode root = new TreeNode(postorder[postorder.length - 1]);
        for(int i = 0; i < inorder.length; i++) {
            if(inorder[i] == root.val) {
                root.left = buildTree(Arrays.copyOfRange(inorder, 0, i), Arrays.copyOfRange(postorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(inorder, i + 1, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length - 1));
            }
        }
        return root;
    //     return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    // private TreeNode build(int[] in, int inL, int inR, int[] post, int postL, int postR) {
    //     if(inL > inR || postL > postR) return null;
    //     TreeNode root = new TreeNode(post[postR]);
    //     int i = 0;
    //     while(in[inL + i] != root.val) i++;
    //     root.left = build(in, inL, inL + i - 1, post, postL, postL + i - 1);
    //     root.right = build(in, inL + i + 1, inR, post, postL + i, postR - 1);
    //     return root;
    // }

}
```

2. [将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums, 0, nums.length);
    }
    TreeNode toBST(int[] nums, int left, int right){
        if(left >= right) return null;
        int mid = left + ((right - left) >> 1);
        TreeNode root = new TreeNode(nums[mid]);
        root.left = toBST(nums, left, mid);
        root.right = toBST(nums, mid + 1, right);
        return root;
    }
}
```

## 5月8号

1. [相同的树](https://leetcode-cn.com/problems/same-tree/)

```Java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null || q == null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

2. [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return help(root) != -1;
    }

    int help(TreeNode root) {
        if(root == null) return 0;
        int left = help(root.left);
        if(left == -1) return -1;
        int right = help(root.right);
        if(right == -1) return -1;
        // 如果左右子树的高度差小于2，那么返回 当前节点的高度，否则剪枝输出 -1
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1: -1;
    }

}
// class Solution {
//     public boolean isBalanced(TreeNode root) {
//         // 如果遍历到叶子节点以下，则返回真
//         if(root == null) return true;   

//         // 对每个遍历的节点，查看其左右子树的高度差是否大于1
//         if(Math.abs(high(root.left) - high(root.right)) > 1) return false;

//         // 前序遍历每一个节点
//         return isBalanced(root.left) && isBalanced(root.right);
//     }

//     private int high(TreeNode root) {
//         if(root == null) return 0;
//         return Math.max(high(root.left), high(root.right)) + 1;
//     }
// }
```

3. [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        if(root.left == null && root.right != null) return minDepth(root.right) + 1;
        if(root.right == null && root.left != null) return minDepth(root.left) + 1;
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}
// 因为最小深度，并不像最大深度那样，每次都遍历到最底部，因为可能左子树为空，右子树不空，那么此时就会直接返回左子树的高度 0 + 1，而不是右子树的高度。这样不能全部遍历到整棵树，所以也无法求得全局最小深度
```

4. [路径总和](https://leetcode-cn.com/problems/path-sum/)

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && sum != root.val) return false;
        if(root.left == null && root.right == null && sum == root.val) return true;
        // if(root.left == null && root.right == null) return sum == root.val;
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

5. [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if(root == null) return res;
        backtrack(root, sum);
        return res;
    }

    void backtrack(TreeNode root, int sum) {
        if(root == null) return;
        if(root.left == null && root.right == null && sum == root.val) {
            path.add(root.val);
            res.add(new ArrayList<>(path));
            path.remove(path.size() - 1);
            return;
        }
        path.add(root.val);
        backtrack(root.left, sum - root.val);
        // path.remove(path.size() - 1);
        // path.add(root.val);
        backtrack(root.right, sum - root.val);
        path.remove(path.size() - 1);
    }
}
```

6. [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

   [填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

```Java
class Solution {
    public Node connect(Node root) {
        if(root == null) return null;
        LinkedList<Node> q = new LinkedList<>();
        q.offer(root);
        while(q.size() > 0) {
            int size = q.size();
            for(int i = 0; i < size; i++) {
                Node t = q.poll();
                if(i == size - 1) { // 此处，不能用队列的size判断，因为下面还会添加Node
                    t.next = null;
                } else {
                    t.next = q.peekFirst();
                }
                if(t.left != null) q.offer(t.left);
                if(t.right != null) q.offer(t.right);
            }
        }
        return root;
    }
}
```

7. [求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```Java
class Solution {
    int sum = 0;
    int path = 0;
    public int sumNumbers(TreeNode root) {
        if(root == null) return sum;
        backtrack(root);
        return sum;
    }

    void backtrack(TreeNode root) {
        if(root == null) return;
        path = path * 10 + root.val;
        if(root.left == null && root.right == null) sum += path;
        backtrack(root.left);
        backtrack(root.right);
        path = (path - root.val) / 10;
    }
}
```

8. [二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

* 这一题要转换思路，题目看起来很麻烦，其实就是很简单的非递归中序遍历

```Java
class BSTIterator {
    Deque<TreeNode> stack;
    public BSTIterator(TreeNode root) {
        stack = new ArrayDeque<>();
        left(root);
    }
    
    private void left(TreeNode root) {
        while(root != null) {
            stack.push(root);
            root = root.left;
        }
    }
    /** @return the next smallest number */
    public int next() {
        TreeNode t = stack.pop();
        left(t.right);
        return t.val;
    }
    
    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return stack.size() > 0;
    }
}
```

9. [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/

```Java
class Trie {

    private TrieNode root;
    /** Initialize your data structure here. */
    public Trie() {
        this.root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode temp = root;
        for(int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            TrieNode node = temp.getSubNode(c);
            if(node == null) {
                node = new TrieNode();
                temp.addSubNode(c, node);
            }
            temp = node;
            if(i == word.length() - 1)
                temp.setEnd(true);
            
        }
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode temp = root;
        for(int i = 0; i < word.length(); i++) {
           TrieNode node = temp.getSubNode(word.charAt(i));
           if(node == null) return false;
           temp = node;
           if(i == word.length() - 1)
                return temp.getEnd();
        }
        return true;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode temp = root;
        for(int i = 0; i < prefix.length(); i++) {
           TrieNode node = temp.getSubNode(prefix.charAt(i));
           if(node == null) return false;
           temp = node;
        }
        return true;
    }

private class TrieNode{

    private Map<Character,TrieNode> subNodes = new HashMap<>();
    private boolean end;

    public void addSubNode(Character key, TrieNode value) {
        subNodes.put(key, value);
    }
    public TrieNode getSubNode(Character key) {
        return subNodes.get(key);
    }
        
    public void setEnd(boolean end) {
        this.end = end;
    }

    public boolean getEnd(){
        return this.end;
    }
}

}
```

## 5月9号

1. [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```Java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        LinkedList<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(q.size() > 0) {
            int size = q.size(); 
            for(int i = 0; i < size; i++) {
                TreeNode t = q.poll();
                if(t.left != null) q.offer(t.left);
                if(t.right != null) q.offer(t.right);
                if(i == size - 1)
                    res.add(t.val);
            }
        }
        return res;
    }
}
```

2. [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        if(root.left == null && root.right == null) return root;
        TreeNode t = root.left;
        root.left = root.right;
        root.right = t;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

3. [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null) {
            if(root == p || root == q || (p.val < root.val && q.val > root.val) || (p.val > root.val && q.val < root.val)) return root;
            if(p.val > root.val && q.val > root.val) root = root.right;
            else root = root.left;
        }
        return root;
    }
}
```

4. [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```Java
class Solution {
    List<String> path = new ArrayList<>();
    List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null) return res;
        backtrack(root);
        return res;
    }

    void backtrack(TreeNode root) {
        if(root == null) return;
        if(root.left == null && root.right == null) {
            path.add(root.val + "");
            res.add(String.join("->",path));
            path.remove(path.size() - 1);
        }
        path.add(root.val + "");
        backtrack(root.left);
        backtrack(root.right);
        path.remove(path.size() - 1);
    }
}
```

5. [二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```Java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode cur = root;
        int i = 0;
        while(stack.size() > 0 || cur != null) {
            while(cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            if(++i == k)
                return cur.val;
            cur = cur.right;
        }
        return 0;
    }
}
```

6. [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

```Java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        sb.append(root.val + ",");
        while(queue.size() > 0) {
            TreeNode temp = queue.poll();
            if(temp.left != null) {
                queue.offer(temp.left);
                sb.append(temp.left.val + ",");
            } else {
                sb.append("null,");
            }
            if(temp.right != null) {
                queue.offer(temp.right);
                sb.append(temp.right.val + ",");
            } else {
                sb.append("null,");
            }
        }
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if("".equals(data)) return null;
        String[] strs = data.split(",");
        TreeNode root = generateTreeNode(strs[0]);
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int index = 1;
        while(queue.size() > 0) {
            TreeNode t = queue.poll();
            t.left = generateTreeNode(strs[index++]);
            if(t.left != null) queue.offer(t.left);
            t.right = generateTreeNode(strs[index++]);
            if(t.right != null) queue.offer(t.right);
        }
        return root;
    }

    private TreeNode generateTreeNode(String str) {
        if("null".equals(str))
            return null;
        return new TreeNode(Integer.parseInt(str));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

7. [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

* 动态规划的 转移方程

```Java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        int res = nums[0];
        for(int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

8. [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```Java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0; 
        if(nums.length == 1) return nums[0];
        return Math.max(get(Arrays.copyOfRange(nums, 0, nums.length - 1)), get(Arrays.copyOfRange(nums, 1, nums.length)));
    }

    public int get(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        int res = dp[1];
        for(int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
    
}
```

9. [打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

```Java
class Solution {
    Map<TreeNode, Integer> memo = new HashMap<>();
    public int rob(TreeNode root) {
        if(root == null) return 0;
        if(memo.containsKey(root)) return memo.get(root);
        int doIt = root.val + 
        (root.left == null ? 0 : rob(root.left.left) + rob(root.left.right)) +  
        (root.right == null ? 0 : rob(root.right.left) + rob(root.right.right));
        int notDoIt = rob(root.left) + rob(root.right);
        int result = Math.max(doIt, notDoIt);
        memo.put(root, result);
        return result;
    }
}
```

10. [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        int min = prices[0];
        int res = 0;
        for(int i = 1; i < prices.length; i++) {
            res = Math.max(res, prices[i] - min);
            min = Math.min(min, prices[i]);
        }
        return res;
    }
}
```

11. [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```Java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        for(int i = 1; i < prices.length; i++) {
            res += prices[i] - prices[i - 1] <= 0 ? 0 : prices[i] - prices[i - 1];
        }
        return res;
    }
}
```

12. [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```Java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;

        int[] dp = new int[prices.length];
        int[] reverseDp = new int[prices.length];

        int min = prices[0];
        for(int i = 1; i < prices.length; i++) {
            min = Math.min(min, prices[i]);
            dp[i] = Math.max(dp[i - 1], prices[i] - min);
        }

        int max = prices[prices.length - 1];
        for(int i = prices.length - 2; i >= 0; i--) {
            max = Math.max(max, prices[i]);
            reverseDp[i] = Math.max(reverseDp[i + 1], max - prices[i]);
        }
        
        int res = dp[prices.length - 1];
        for(int i = 0; i < prices.length - 1; i++) {
            res = Math.max(res, dp[i] + reverseDp[i + 1]);
        }
        return res;
    }
}
```

